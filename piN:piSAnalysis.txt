###################################################################
###################################################################
#####               p i N   /   p i S   Analysis              #####
###################################################################
###################################################################

###############################################################
######    Generating VCFs from Multifasta (.fas) files   ######
###############################################################

# This code assumes you have generated the multifasta files for each chromosome arm (see 'DGRP.Processing.txt')

# Making VCF files that contain both variant and invariant sites from .fas  multi-alignment files
~/apps/snp-sites/bin/snp-sites -v -b -o ChrX.variant.and.invariant.test.vcf ChrX.fas &
~/apps/snp-sites/bin/snp-sites -v -b -o Chr2L.variant.and.invariant.vcf Chr2L.fas &
~/apps/snp-sites/bin/snp-sites -v -b -o Chr2R.variant.and.invariant.vcf Chr2R.fas &
~/apps/snp-sites/bin/snp-sites -v -b -o Chr3L.variant.and.invariant.vcf Chr3L.fas &
~/apps/snp-sites/bin/snp-sites -v -b -o Chr3R.variant.and.invariant.vcf Chr3R.fas &

## Prepare VCF files for liftOver to convert coordinates from release 5 (dm3) -> release 6 (dm6)
# Redirect header to attach to VCF later
cat Chr2L.variant.and.invariant.vcf | grep '#' > vcf.header

Remove sites with no genotypic information
sed -i '/N/d' Chr2L.variant.and.invariant.vcf &
sed -i '/N/d' Chr2R.variant.and.invariant.vcf &
sed -i '/N/d' Chr3L.variant.and.invariant.vcf &
sed -i '/N/d' Chr3R.variant.and.invariant.vcf &
sed -i '/N/d' ChrX.variant.and.invariant.vcf &

# Remove headers from vcf files
sed -i '/^#/d' Chr2L.variant.and.invariant.vcf &
sed -i '/^#/d' Chr2R.variant.and.invariant.vcf &
sed -i '/^#/d' Chr3L.variant.and.invariant.vcf &
sed -i '/^#/d' Chr3R.variant.and.invariant.vcf &
sed -i '/^#/d' ChrX.variant.and.invariant.vcf &

# Replace Chromosome column with proper ID
cat Chr2L.variant.and.invariant.vcf | awk -F"\t" '{OFS=FS}{ $1="2L" ; print   }' > Chr2L.tmp && mv Chr2L.tmp Chr2L.variant.and.invariant.vcf &
cat Chr2R.variant.and.invariant.vcf | awk -F"\t" '{OFS=FS}{ $1="2R" ; print   }' > Chr2R.tmp && mv Chr2R.tmp Chr2R.variant.and.invariant.vcf &
cat Chr3L.variant.and.invariant.vcf | awk -F"\t" '{OFS=FS}{ $1="3L" ; print   }' > Chr3L.tmp && mv Chr3L.tmp Chr3L.variant.and.invariant.vcf &
cat Chr3R.variant.and.invariant.vcf | awk -F"\t" '{OFS=FS}{ $1="3R" ; print   }' > Chr3R.tmp && mv Chr3R.tmp Chr3R.variant.and.invariant.vcf &
cat ChrX.variant.and.invariant.vcf | awk -F"\t" '{OFS=FS}{ $1="X" ; print   }' > ChrX.tmp && mv ChrX.tmp ChrX.variant.and.invariant.vcf &
rm Chr*.tmp

# Add a unique ID column that can be used to reattach to lifted over coordinates
cat Chr2L.variant.and.invariant.vcf | awk 'BEGIN {OFS=FS="\t"}{print $1 ":" $2}' | paste - Chr2L.variant.and.invariant.vcf | cut -f 1,4-$NF > Chr2L.variant.and.invariant.vcf.tmp &
cat Chr2R.variant.and.invariant.vcf | awk 'BEGIN {OFS=FS="\t"}{print $1 ":" $2}' | paste - Chr2R.variant.and.invariant.vcf | cut -f 1,4-$NF > Chr2R.variant.and.invariant.vcf.tmp &
cat Chr3L.variant.and.invariant.vcf | awk 'BEGIN {OFS=FS="\t"}{print $1 ":" $2}' | paste - Chr3L.variant.and.invariant.vcf | cut -f 1,4-$NF > Chr3L.variant.and.invariant.vcf.tmp &
cat Chr3R.variant.and.invariant.vcf | awk 'BEGIN {OFS=FS="\t"}{print $1 ":" $2}' | paste - Chr3R.variant.and.invariant.vcf | cut -f 1,4-$NF > Chr3R.variant.and.invariant.vcf.tmp &
cat ChrX.variant.and.invariant.vcf | awk 'BEGIN {OFS=FS="\t"}{print $1 ":" $2}' | paste - ChrX.variant.and.invariant.vcf | cut -f 1,4-$NF > ChrX.variant.and.invariant.vcf.tmp &

# Make columns with coordinates in BED format for liftOver
cat Chr2L.variant.and.invariant.vcf | awk 'BEGIN { OFS=FS="\t" }{print "chr" $1, $2-1, $2 }' | paste - Chr2L.variant.and.invariant.vcf > Chr2L.variant.and.invariant.vcf.for.liftover &
cat Chr2R.variant.and.invariant.vcf | awk 'BEGIN { OFS=FS="\t" }{print "chr" $1, $2-1, $2 }' | paste - Chr2R.variant.and.invariant.vcf > Chr2R.variant.and.invariant.vcf.for.liftover &
cat Chr3L.variant.and.invariant.vcf | awk 'BEGIN { OFS=FS="\t" }{print "chr" $1, $2-1, $2 }' | paste - Chr3L.variant.and.invariant.vcf > Chr3L.variant.and.invariant.vcf.for.liftover &
cat Chr3R.variant.and.invariant.vcf | awk 'BEGIN { OFS=FS="\t" }{print "chr" $1, $2-1, $2 }' | paste - Chr3R.variant.and.invariant.vcf > Chr3R.variant.and.invariant.vcf.for.liftover &
cat ChrX.variant.and.invariant.vcf | awk 'BEGIN { OFS=FS="\t" }{print "chr" $1, $2-1, $2 }' | paste - ChrX.variant.and.invariant.vcf > ChrX.variant.and.invariant.vcf.for.liftover &

# Liftover from assembly dm3 to dm6
liftOver -bedPlus=3 -tab /plas1/amardeep.singh/GenomicsMaleFemaleArchitecture/GenomicData/DGRP.Genomic.Data/Chr2L.variant.and.invariant.vcf.for.liftover /plas1/amardeep.singh/GenomicsMaleFemaleArchitecture/GenomicData/dm3ToDm6.over.chain /plas1/amardeep.singh/GenomicsMaleFemaleArchitecture/GenomicData/DGRP.Genomic.Data/Chr2L.liftedover.vcf Chr2L.unlifted.bed &
liftOver -bedPlus=3 -tab /plas1/amardeep.singh/GenomicsMaleFemaleArchitecture/GenomicData/DGRP.Genomic.Data/Chr2R.variant.and.invariant.vcf.for.liftover /plas1/amardeep.singh/GenomicsMaleFemaleArchitecture/GenomicData/dm3ToDm6.over.chain /plas1/amardeep.singh/GenomicsMaleFemaleArchitecture/GenomicData/DGRP.Genomic.Data/Chr2R.liftedover.vcf Chr2R.unlifted.bed &
liftOver -bedPlus=3 -tab /plas1/amardeep.singh/GenomicsMaleFemaleArchitecture/GenomicData/DGRP.Genomic.Data/Chr3L.variant.and.invariant.vcf.for.liftover /plas1/amardeep.singh/GenomicsMaleFemaleArchitecture/GenomicData/dm3ToDm6.over.chain /plas1/amardeep.singh/GenomicsMaleFemaleArchitecture/GenomicData/DGRP.Genomic.Data/Chr3L.liftedover.vcf Chr3L.unlifted.bed &
liftOver -bedPlus=3 -tab /plas1/amardeep.singh/GenomicsMaleFemaleArchitecture/GenomicData/DGRP.Genomic.Data/Chr3R.variant.and.invariant.vcf.for.liftover /plas1/amardeep.singh/GenomicsMaleFemaleArchitecture/GenomicData/dm3ToDm6.over.chain /plas1/amardeep.singh/GenomicsMaleFemaleArchitecture/GenomicData/DGRP.Genomic.Data/Chr3R.liftedover.vcf Chr3R.unlifted.bed &
liftOver -bedPlus=3 -tab /plas1/amardeep.singh/GenomicsMaleFemaleArchitecture/GenomicData/DGRP.Genomic.Data/ChrX.variant.and.invariant.vcf.for.liftover /plas1/amardeep.singh/GenomicsMaleFemaleArchitecture/GenomicData/dm3ToDm6.over.chain /plas1/amardeep.singh/GenomicsMaleFemaleArchitecture/GenomicData/DGRP.Genomic.Data/ChrX.liftedover.vcf ChrX.unlifted.bed &

## Add a unique ID column with the old coordinates so that I can intersect the old and new vcfs to recover all individual genotypes
## NOTE: THESE OUTPUT FILES ARE NOW 1 BASED!
cat Chr2L.liftedover.vcf | awk 'BEGIN {OFS=FS="\t"}{print $4 ":" $5, $4, $3}' > Chr2L.liftedOver.Coordinates &
cat Chr2R.liftedover.vcf | awk 'BEGIN {OFS=FS="\t"}{print $4 ":" $5, $4, $3}' > Chr2R.liftedOver.Coordinates &
cat Chr3L.liftedover.vcf | awk 'BEGIN {OFS=FS="\t"}{print $4 ":" $5, $4, $3}' > Chr3L.liftedOver.Coordinates &
cat Chr3R.liftedover.vcf | awk 'BEGIN {OFS=FS="\t"}{print $4 ":" $5, $4, $3}' > Chr3R.liftedOver.Coordinates &
cat ChrX.liftedover.vcf | awk 'BEGIN {OFS=FS="\t"}{print $4 ":" $5, $4, $3}' > ChrX.liftedOver.Coordinates &

# Now file with new coordinates to file with genotypic info on all individuals to make VCF with release 6 coordinates
join -j 1 -t $'\t' Chr2L.liftedOver.Coordinates Chr2L.variant.and.invariant.vcf.tmp | cut -f 2-$NF > Chr2L.variant.invariant.release6.vcf &
join -j 1 -t $'\t' Chr2R.liftedOver.Coordinates Chr2R.variant.and.invariant.vcf.tmp | cut -f 2-$NF > Chr2R.variant.invariant.release6.vcf &
join -j 1 -t $'\t' Chr3L.liftedOver.Coordinates Chr3L.variant.and.invariant.vcf.tmp | cut -f 2-$NF > Chr3L.variant.invariant.release6.vcf &
join -j 1 -t $'\t' Chr3R.liftedOver.Coordinates Chr3R.variant.and.invariant.vcf.tmp | cut -f 2-$NF > Chr3R.variant.invariant.release6.vcf &
join -j 1 -t $'\t' ChrX.liftedOver.Coordinates ChrX.variant.and.invariant.vcf.tmp | cut -f 2-$NF > ChrX.variant.invariant.release6.vcf &



#######################################################################
######    Generating lists of 0fold and 4fold degenerate sites   ######
#######################################################################

# Run the 'DegeneracyScript' provided by Tyler Kent
# The code can be run as a bash script but I just ran each step separately so make sure to modify the input/output files
#   and make sure all your files are where they need to be

# Extract coordinates for each site (these bed files are 0-based and need to be updated to 1-based to match the vcf files - just take the third field as the starting site)
cat DGRP.2L.bedout_0fold.bed | awk '{OFS = FS = "\t"} {print $1 ":" $2+1}' > DGRP.2L.bedout_0fold.coordinates &
cat DGRP.2L.bedout_4fold.bed | awk '{OFS = FS = "\t"} {print $1 ":" $2+1}' > DGRP.2L.bedout_4fold.coordinates &
cat DGRP.2R.bedout_0fold.bed | awk '{OFS = FS = "\t"} {print $1 ":" $2+1}' > DGRP.2R.bedout_0fold.coordinates &
cat DGRP.2R.bedout_4fold.bed | awk '{OFS = FS = "\t"} {print $1 ":" $2+1}' > DGRP.2R.bedout_4fold.coordinates &

cat DGRP.3L.bedout_0fold.bed | awk '{OFS = FS = "\t"} {print $1 ":" $2+1}' > DGRP.3L.bedout_0fold.coordinates &
cat DGRP.3L.bedout_4fold.bed | awk '{OFS = FS = "\t"} {print $1 ":" $2+1}' > DGRP.3L.bedout_4fold.coordinates &
cat DGRP.3R.bedout_0fold.bed | awk '{OFS = FS = "\t"} {print $1 ":" $2+1}' > DGRP.3R.bedout_0fold.coordinates &
cat DGRP.3R.bedout_4fold.bed | awk '{OFS = FS = "\t"} {print $1 ":" $2+1}' > DGRP.3R.bedout_4fold.coordinates &

cat DGRP.X.bedout_0fold.bed | awk '{OFS = FS = "\t"} {print $1 ":" $2+1}' > DGRP.X.bedout_0fold.coordinates &
cat DGRP.X.bedout_4fold.bed | awk '{OFS = FS = "\t"} {print $1 ":" $2+1}' > DGRP.X.bedout_4fold.coordinates &


##################################################################################################################
######   Parse out vcf files into one containing only 0fold sites and another containing only 4fold sites   ######
##################################################################################################################


# Adding a unique ID column that will be used to clean out sites that don't match the 4fold and 0fold degenerate sites list
cat Chr2L.variant.and.invariant.vcf | awk '{print $1 ":" $2}' | paste - Chr2L.variant.and.invariant.vcf > Chr2L.variant.and.invariant.vcf.tmp &
cat Chr2R.variant.and.invariant.vcf | awk '{print $1 ":" $2}' | paste - Chr2R.variant.and.invariant.vcf > Chr2R.variant.and.invariant.vcf.tmp &
cat Chr3L.variant.and.invariant.vcf | awk '{print $1 ":" $2}' | paste - Chr3L.variant.and.invariant.vcf > Chr3L.variant.and.invariant.vcf.tmp &
cat Chr3R.variant.and.invariant.vcf | awk '{print $1 ":" $2}' | paste - Chr3R.variant.and.invariant.vcf > Chr3R.variant.and.invariant.vcf.tmp &
cat ChrX.variant.and.invariant.vcf | awk '{print $1 ":" $2}' | paste - ChrX.variant.and.invariant.vcf > ChrX.variant.and.invariant.vcf.tmp &


# Compare to 4fold and 0fold coordinate sites to generate parsed VCFs for each type of variant
grep -w -F -f /plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/TylersCode/bedOut/DGRP.2L.bedout_0fold.coordinates Chr2L.variant.and.invariant.vcf.tmp > /plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/4fold0fold.parsedVCFs/Chr2L.0fold.vcf &
grep -w -F -f /plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/TylersCode/bedOut/DGRP.2L.bedout_4fold.coordinates Chr2L.variant.and.invariant.vcf.tmp > /plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/4fold0fold.parsedVCFs/Chr2L.4fold.vcf &
grep -w -F -f /plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/TylersCode/bedOut/DGRP.2R.bedout_0fold.coordinates Chr2R.variant.and.invariant.vcf.tmp > /plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/4fold0fold.parsedVCFs/Chr2R.0fold.vcf &
grep -w -F -f /plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/TylersCode/bedOut/DGRP.2R.bedout_4fold.coordinates Chr2R.variant.and.invariant.vcf.tmp > /plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/4fold0fold.parsedVCFs/Chr2R.4fold.vcf &

grep -w -F -f /plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/TylersCode/bedOut/DGRP.3L.bedout_0fold.coordinates Chr3L.variant.and.invariant.vcf.tmp > /plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/4fold0fold.parsedVCFs/Chr3L.0fold.vcf &
grep -w -F -f /plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/TylersCode/bedOut/DGRP.3L.bedout_4fold.coordinates Chr3L.variant.and.invariant.vcf.tmp > /plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/4fold0fold.parsedVCFs/Chr3L.4fold.vcf &
grep -w -F -f /plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/TylersCode/bedOut/DGRP.3R.bedout_0fold.coordinates Chr3R.variant.and.invariant.vcf.tmp > /plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/4fold0fold.parsedVCFs/Chr3R.0fold.vcf &
grep -w -F -f /plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/TylersCode/bedOut/DGRP.3R.bedout_4fold.coordinates Chr3R.variant.and.invariant.vcf.tmp > /plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/4fold0fold.parsedVCFs/Chr3R.4fold.vcf &

grep -w -F -f /plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/TylersCode/bedOut/DGRP.X.bedout_0fold.coordinates ChrX.variant.and.invariant.vcf.tmp > /plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/4fold0fold.parsedVCFs/ChrX.0fold.vcf &
grep -w -F -f /plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/TylersCode/bedOut/DGRP.X.bedout_4fold.coordinates ChrX.variant.and.invariant.vcf.tmp > /plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/4fold0fold.parsedVCFs/ChrX.4fold.vcf &

## Remove ID column before processing VCF
cat Chr2L.0fold.vcf | cut -f 2-$NF > Chr2L.0fold.vcf.tmp && mv Chr2L.0fold.vcf.tmp Chr2L.0fold.vcf &
cat Chr2L.4fold.vcf | cut -f 2-$NF > Chr2L.4fold.vcf.tmp && mv Chr2L.4fold.vcf.tmp Chr2L.4fold.vcf &
cat Chr2R.0fold.vcf | cut -f 2-$NF > Chr2R.0fold.vcf.tmp && mv Chr2R.0fold.vcf.tmp Chr2R.0fold.vcf &
cat Chr2R.4fold.vcf | cut -f 2-$NF > Chr2R.4fold.vcf.tmp && mv Chr2R.4fold.vcf.tmp Chr2R.4fold.vcf &
cat Chr3L.0fold.vcf | cut -f 2-$NF > Chr3L.0fold.vcf.tmp && mv Chr3L.0fold.vcf.tmp Chr3L.0fold.vcf &
cat Chr3L.4fold.vcf | cut -f 2-$NF > Chr3L.4fold.vcf.tmp && mv Chr3L.4fold.vcf.tmp Chr3L.4fold.vcf &
cat Chr3R.0fold.vcf | cut -f 2-$NF > Chr3R.0fold.vcf.tmp && mv Chr3R.0fold.vcf.tmp Chr3R.0fold.vcf &
cat Chr3R.4fold.vcf | cut -f 2-$NF > Chr3R.4fold.vcf.tmp && mv Chr3R.4fold.vcf.tmp Chr3R.4fold.vcf &
cat ChrX.0fold.vcf | cut -f 2-$NF > ChrX.0fold.vcf.tmp && mv ChrX.0fold.vcf.tmp ChrX.0fold.vcf &
cat ChrX.4fold.vcf | cut -f 2-$NF > ChrX.4fold.vcf.tmp && mv ChrX.4fold.vcf.tmp ChrX.4fold.vcf &



##########################################################
### Convert SNP-sits VCF format to "Normal VCF" format ###    ## I forked this code form Ruzicka et al 2019 PLoS Bio
##########################################################

## Modify this code before running it! - Tell R which VCF to work with

#----- R code -----
rm(list=ls())
require(matrixStats)

## Modify VCF for Tajima's D analysis (r5 coordinates + remove positions where depth<20)

## Import vcf files of interest ## Need to change these two depending on the specific file
chr.vcf <- read.table("/plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/4fold0fold.parsedVCFs/ChrX.4fold.vcf")
print("Chromosome Loaded!")
output.name = "chr.X.4fold"
chr.number = "X"

#Sanity check
#plot(rownames(test.vcf),test.vcf$V2)

#Three possible types of acceptable allele
#No missing values
type1 <- c("A","T","G","C")
part1 <- subset(chr.vcf,V5 %in% type1)
if (nrow(part1) > 0) {
part1[part1==1] <- "1/1"
part1[part1==0] <- "0/0"
}

#Missing value = 2
type2 <- c("A,*","T,*","G,*","C,*")
part2 <- subset(chr.vcf,V5 %in% type2)
if (nrow(part2) > 0) {
part2[part2==2] <- "N/N"
part2[part2==1] <- "1/1"
part2[part2==0] <- "0/0" }
part2$V5 <- ifelse(part2$V5=="A,*","A",ifelse(part2$V5=="T,*","T",ifelse(part2$V5=="C,*","C",ifelse(part2$V5=="G,*","G",NA))))

#Missing value = 1
type3 <- c("*,A","*,T","*,G","*,C")
part3 <- subset(chr.vcf,V5 %in% type3)
if (nrow(part3) > 0) {
part3[part3==2] <- "1/1"
part3[part3==1] <- "N/N"
part3[part3==0] <- "0/0"
part3$V5 <- ifelse(part3$V5=="*,A","A",ifelse(part3$V5=="*,T","T",ifelse(part3$V5=="*,C","C",ifelse(part3$V5=="*,G","G",NA))))
}

#Missing value = none, i.e., this site is monomorphic
type4 <- c("*")
part4 <- subset(chr.vcf,V5 %in% type4)
if (nrow(part4) > 0) {
part4[part4==0] <- "0/0"
part4[part4==1] <- "N/N"
part4$V5 <- "."
}

#Rbind parts 1,2,3,4
vcf <- rbind(part1,part2,part3,part4)
#Transform position column to numeric
vcf$V2 <- as.numeric(vcf$V2)
#Order by position column
vcf <- vcf[order(vcf$V2),]
#Replace chromosome column with 1
vcf$V1 <- chr.number
#Filter for depth (DP>19)
vcf <- subset(vcf,rowCounts(vcf[,10:ncol(vcf)]!="./.")>41) # This now removes any sites that have more than 20% missing data
vcf$V2 <- format(vcf$V2,scientific=F)

write.table(vcf, file = paste("/plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/4fold0fold.parsedVCFs/", output.name, "_modified.vcf", sep = ""), sep="\t",row.names = F, quote=F, col.names=F)

rm(list=ls())

# ---- /R Code ----

# Add header back to vcf files
cat vcf.header chr.2L.0fold_modified.vcf > chr.2L.0fold_modified.vcf.tmp && mv chr.2L.0fold_modified.vcf.tmp chr.2L.0fold_modified.vcf &
cat vcf.header chr.2L.4fold_modified.vcf > chr.2L.4fold_modified.vcf.tmp && mv chr.2L.4fold_modified.vcf.tmp chr.2L.4fold_modified.vcf &
cat vcf.header chr.2R.0fold_modified.vcf > chr.2R.0fold_modified.vcf.tmp && mv chr.2R.0fold_modified.vcf.tmp chr.2R.0fold_modified.vcf &
cat vcf.header chr.2R.4fold_modified.vcf > chr.2R.4fold_modified.vcf.tmp && mv chr.2R.4fold_modified.vcf.tmp chr.2R.4fold_modified.vcf &
cat vcf.header chr.3L.0fold_modified.vcf > chr.3L.0fold_modified.vcf.tmp && mv chr.3L.0fold_modified.vcf.tmp chr.3L.0fold_modified.vcf &
cat vcf.header chr.3L.4fold_modified.vcf > chr.3L.4fold_modified.vcf.tmp && mv chr.3L.4fold_modified.vcf.tmp chr.3L.4fold_modified.vcf &
cat vcf.header chr.3R.0fold_modified.vcf > chr.3R.0fold_modified.vcf.tmp && mv chr.3R.0fold_modified.vcf.tmp chr.3R.0fold_modified.vcf &
cat vcf.header chr.3R.4fold_modified.vcf > chr.3R.4fold_modified.vcf.tmp && mv chr.3R.4fold_modified.vcf.tmp chr.3R.4fold_modified.vcf &
cat vcf.header chr.X.0fold_modified.vcf > chr.X.0fold_modified.vcf.tmp && mv chr.X.0fold_modified.vcf.tmp chr.X.0fold_modified.vcf &
cat vcf.header chr.X.4fold_modified.vcf > chr.X.4fold_modified.vcf.tmp && mv chr.X.4fold_modified.vcf.tmp chr.X.4fold_modified.vcf &

## Parse VCF to convert into a format for Simon Martin's geno.file
python3 parseVCF.py -i chr.2L.0fold_modified.vcf --skipIndels > chr.2L.0fold_genofile.vcf &
python3 parseVCF.py -i chr.2L.4fold_modified.vcf --skipIndels > chr.2L.4fold_genofile.vcf &
python3 parseVCF.py -i chr.2R.0fold_modified.vcf --skipIndels > chr.2R.0fold_genofile.vcf &
python3 parseVCF.py -i chr.2R.4fold_modified.vcf --skipIndels > chr.2R.4fold_genofile.vcf &
python3 parseVCF.py -i chr.3L.0fold_modified.vcf --skipIndels > chr.3L.0fold_genofile.vcf &
python3 parseVCF.py -i chr.3L.4fold_modified.vcf --skipIndels > chr.3L.4fold_genofile.vcf &
python3 parseVCF.py -i chr.3R.0fold_modified.vcf --skipIndels > chr.3R.0fold_genofile.vcf &
python3 parseVCF.py -i chr.3R.4fold_modified.vcf --skipIndels > chr.3R.4fold_genofile.vcf &
python3 parseVCF.py -i chr.X.0fold_modified.vcf --skipIndels > chr.X.0fold_genofile.vcf &
python3 parseVCF.py -i chr.X.4fold_modified.vcf --skipIndels > chr.X.4fold_genofile.vcf &

python3 popgenWindows.py -w 1 -m 1 -g chr.2L.0fold_genofile.vcf -o chr.2L.0fold.output.csv.gz -f phased -T 20 &
python3 popgenWindows.py -w 1 -m 1 -g chr.2L.4fold_genofile.vcf -o chr.2L.4fold.output.csv.gz -f phased -T 20 &
python3 popgenWindows.py -w 1 -m 1 -g chr.2R.0fold_genofile.vcf -o chr.2R.0fold.output.csv.gz -f phased -T 20 &
python3 popgenWindows.py -w 1 -m 1 -g chr.2R.4fold_genofile.vcf -o chr.2R.4fold.output.csv.gz -f phased -T 10 &

python3 popgenWindows.py -w 1 -m 1 -g chr.3L.0fold_genofile.vcf -o chr.3L.0fold.output.csv.gz -f phased -T 20 &
python3 popgenWindows.py -w 1 -m 1 -g chr.3L.4fold_genofile.vcf -o chr.3L.4fold.output.csv.gz -f phased -T 20 &
python3 popgenWindows.py -w 1 -m 1 -g chr.3R.0fold_genofile.vcf -o chr.3R.0fold.output.csv.gz -f phased -T 20 &
python3 popgenWindows.py -w 1 -m 1 -g chr.3R.4fold_genofile.vcf -o chr.3R.4fold.output.csv.gz -f phased -T 20 &
python3 popgenWindows.py -w 1 -m 1 -g chr.X.0fold_genofile.vcf -o chr.X.0fold.output.csv.gz -f phased -T 20 &
python3 popgenWindows.py -w 1 -m 1 -g chr.X.4fold_genofile.vcf -o chr.X.4fold.output.csv.gz -f phased -T 20 &

#############################################################################################
######    Calculating Nucleotide Diversity in the DGRP and Assigning Sites to genes    ######
#############################################################################################

cat /plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/4fold0fold.parsedVCFs/chr.2L.4fold_modified.vcf | vcftools --vcf - --site-pi --out  /plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/4fold0fold.parsedVCFs/NucelotideDiversityFiles/Chr2L.4fold &
cat /plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/4fold0fold.parsedVCFs/chr.2L.0fold_modified.vcf | vcftools --vcf - --site-pi --out  /plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/4fold0fold.parsedVCFs/NucelotideDiversityFiles/Chr2L.0fold &
cat /plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/4fold0fold.parsedVCFs/chr.2R.4fold_modified.vcf | vcftools --vcf - --site-pi --out  /plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/4fold0fold.parsedVCFs/NucelotideDiversityFiles/Chr2R.4fold &
cat /plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/4fold0fold.parsedVCFs/chr.2R.0fold_modified.vcf | vcftools --vcf - --site-pi --out  /plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/4fold0fold.parsedVCFs/NucelotideDiversityFiles/Chr2R.0fold &
cat /plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/4fold0fold.parsedVCFs/chr.3L.4fold_modified.vcf | vcftools --vcf - --site-pi --out  /plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/4fold0fold.parsedVCFs/NucelotideDiversityFiles/Chr3L.4fold &
cat /plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/4fold0fold.parsedVCFs/chr.3L.0fold_modified.vcf | vcftools --vcf - --site-pi --out  /plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/4fold0fold.parsedVCFs/NucelotideDiversityFiles/Chr3L.0fold &
cat /plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/4fold0fold.parsedVCFs/chr.3R.4fold_modified.vcf | vcftools --vcf - --site-pi --out  /plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/4fold0fold.parsedVCFs/NucelotideDiversityFiles/Chr3R.4fold &
cat /plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/4fold0fold.parsedVCFs/chr.3R.0fold_modified.vcf | vcftools --vcf - --site-pi --out  /plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/4fold0fold.parsedVCFs/NucelotideDiversityFiles/Chr3R.0fold &
cat /plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/4fold0fold.parsedVCFs/chr.X.4fold_modified.vcf | vcftools --vcf - --site-pi --out  /plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/4fold0fold.parsedVCFs/NucelotideDiversityFiles/ChrX.4fold &
cat /plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/4fold0fold.parsedVCFs/chr.X.0fold_modified.vcf | vcftools --vcf - --site-pi --out  /plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/4fold0fold.parsedVCFs/NucelotideDiversityFiles/ChrX.0fold &

# I moved the output file to a folder where I kept the rest of the data generated in this script
mv *.pi NucelotideDiversityFiles/

## Intersect with GFF to identify genes that each site falls into
# This is probably a roundabout way to do this, but whatever
# Make separate GFF files for each chromosome arm, correctly formatted to intersect with a BED file that is 0based
grep '2L' Drosophila_melanogaster.BDGP6.28.99.chr.gtf | awk 'BEGIN {OFS =FS="\t"} {print "chr" $1, $2, $3, $4-1, $5,$6,$7,$8,$9}' > Chr2L.gff &
grep '2R' Drosophila_melanogaster.BDGP6.28.99.chr.gtf | awk 'BEGIN {OFS =FS="\t"} {print "chr" $1, $2, $3, $4-1, $5,$6,$7,$8,$9}' > Chr2R.gff &
grep '3L' Drosophila_melanogaster.BDGP6.28.99.chr.gtf | awk 'BEGIN {OFS =FS="\t"} {print "chr" $1, $2, $3, $4-1, $5,$6,$7,$8,$9}' > Chr3L.gff &
grep '3R' Drosophila_melanogaster.BDGP6.28.99.chr.gtf | awk 'BEGIN {OFS =FS="\t"} {print "chr" $1, $2, $3, $4-1, $5,$6,$7,$8,$9}' > Chr3R.gff &
grep 'X' Drosophila_melanogaster.BDGP6.28.99.chr.gtf | awk 'BEGIN {OFS =FS="\t"} {print "chr" $1, $2, $3, $4-1, $5,$6,$7,$8,$9}' > ChrX.gff &

# Format the nucleotide diversity files
grep '2L' Chr2L.0fold.sites.pi | awk 'BEGIN {OFS =FS="\t"} {print "chr" $1, $2-1, $2, $3}' > Chr2L.0fold.sites.pi.for.bedtools &
grep '2L' Chr2L.4fold.sites.pi | awk 'BEGIN {OFS =FS="\t"} {print "chr" $1, $2-1, $2, $3}' > Chr2L.4fold.sites.pi.for.bedtools &
grep '2R' Chr2R.0fold.sites.pi | awk 'BEGIN {OFS =FS="\t"} {print "chr" $1, $2-1, $2, $3}' > Chr2R.0fold.sites.pi.for.bedtools &
grep '2R' Chr2R.4fold.sites.pi | awk 'BEGIN {OFS =FS="\t"} {print "chr" $1, $2-1, $2, $3}' > Chr2R.4fold.sites.pi.for.bedtools &
grep '3L' Chr3L.0fold.sites.pi | awk 'BEGIN {OFS =FS="\t"} {print "chr" $1, $2-1, $2, $3}' > Chr3L.0fold.sites.pi.for.bedtools &
grep '3L' Chr3L.4fold.sites.pi | awk 'BEGIN {OFS =FS="\t"} {print "chr" $1, $2-1, $2, $3}' > Chr3L.4fold.sites.pi.for.bedtools &
grep '3R' Chr3R.0fold.sites.pi | awk 'BEGIN {OFS =FS="\t"} {print "chr" $1, $2-1, $2, $3}' > Chr3R.0fold.sites.pi.for.bedtools &
grep '3R' Chr3R.4fold.sites.pi | awk 'BEGIN {OFS =FS="\t"} {print "chr" $1, $2-1, $2, $3}' > Chr3R.4fold.sites.pi.for.bedtools &
grep 'X' ChrX.0fold.sites.pi | awk 'BEGIN {OFS =FS="\t"} {print "chr" $1, $2-1, $2, $3}' > ChrX.0fold.sites.pi.for.bedtools &
grep 'X' ChrX.4fold.sites.pi | awk 'BEGIN {OFS =FS="\t"} {print "chr" $1, $2-1, $2, $3}' > ChrX.4fold.sites.pi.for.bedtools &

## Intersect files with bedtools
bedtools intersect  -a Chr2L.0fold.sites.pi.for.bedtools -b Chr2L.gff -wa -wb > Chr2L.0Fold.bedtools.out &
bedtools intersect  -a Chr2L.4fold.sites.pi.for.bedtools -b Chr2L.gff -wa -wb > Chr2L.4Fold.bedtools.out &
bedtools intersect  -a Chr2R.0fold.sites.pi.for.bedtools -b Chr2R.gff -wa -wb > Chr2R.0Fold.bedtools.out &
bedtools intersect  -a Chr2R.4fold.sites.pi.for.bedtools -b Chr2R.gff -wa -wb > Chr2R.4Fold.bedtools.out &
bedtools intersect  -a Chr3L.0fold.sites.pi.for.bedtools -b Chr3L.gff -wa -wb > Chr3L.0Fold.bedtools.out &
bedtools intersect  -a Chr3L.4fold.sites.pi.for.bedtools -b Chr3L.gff -wa -wb > Chr3L.4Fold.bedtools.out &
bedtools intersect  -a Chr3R.0fold.sites.pi.for.bedtools -b Chr3R.gff -wa -wb > Chr3R.0Fold.bedtools.out &
bedtools intersect  -a Chr3R.4fold.sites.pi.for.bedtools -b Chr3R.gff -wa -wb > Chr3R.4Fold.bedtools.out &
bedtools intersect  -a ChrX.0fold.sites.pi.for.bedtools -b ChrX.gff -wa -wb > ChrX.0Fold.bedtools.out &
bedtools intersect  -a ChrX.4fold.sites.pi.for.bedtools -b ChrX.gff -wa -wb > ChrX.4Fold.bedtools.out &

## Clean up output files so that they can be read into R
cat Chr2L.0Fold.bedtools.out | sed 's/;/\t/g' | sed 's/ //g' | awk '{OFS = FS = "\t"} {print $1, $3, $4, $13}' > Chr2L.0fold.final &
cat Chr2L.4Fold.bedtools.out | sed 's/;/\t/g' | sed 's/ //g' | awk '{OFS = FS = "\t"} {print $1, $3, $4, $13}' > Chr2L.4fold.final &
cat Chr2R.0Fold.bedtools.out | sed 's/;/\t/g' | sed 's/ //g' | awk '{OFS = FS = "\t"} {print $1, $3, $4, $13}' > Chr2R.0fold.final &
cat Chr2R.4Fold.bedtools.out | sed 's/;/\t/g' | sed 's/ //g' | awk '{OFS = FS = "\t"} {print $1, $3, $4, $13}' > Chr2R.4fold.final &
cat Chr3L.0Fold.bedtools.out | sed 's/;/\t/g' | sed 's/ //g' | awk '{OFS = FS = "\t"} {print $1, $3, $4, $13}' > Chr3L.0fold.final &
cat Chr3L.4Fold.bedtools.out | sed 's/;/\t/g' | sed 's/ //g' | awk '{OFS = FS = "\t"} {print $1, $3, $4, $13}' > Chr3L.4fold.final &
cat Chr3R.0Fold.bedtools.out | sed 's/;/\t/g' | sed 's/ //g' | awk '{OFS = FS = "\t"} {print $1, $3, $4, $13}' > Chr3R.0fold.final &
cat Chr3R.4Fold.bedtools.out | sed 's/;/\t/g' | sed 's/ //g' | awk '{OFS = FS = "\t"} {print $1, $3, $4, $13}' > Chr3R.4fold.final &
cat ChrX.0Fold.bedtools.out | sed 's/;/\t/g' | sed 's/ //g' | awk '{OFS = FS = "\t"} {print $1, $3, $4, $13}' > ChrX.0fold.final &
cat ChrX.4Fold.bedtools.out | sed 's/;/\t/g' | sed 's/ //g' | awk '{OFS = FS = "\t"} {print $1, $3, $4, $13}' > ChrX.4fold.final &

## Merge 4fold and 0fold files together
cat Chr2L.0fold.final Chr2R.0fold.final Chr3L.0fold.final Chr3R.0fold.final ChrX.0fold.final > diversity.0fold.sites &
cat Chr2L.4fold.final Chr2R.4fold.final Chr3L.4fold.final Chr3R.4fold.final ChrX.4fold.final > diversity.4fold.sites &

# Remove intermediate files
rm Chr*.*Fold.bedtools.out
rm *.for.bedtools
rm Chr*.gff

# ---- R CODE ----
rm(list=ls())
require(doBy)

# Read in nucleotide diversity data
diversity.0fold = read.delim("/plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/4fold0fold.parsedVCFs/NucelotideDiversityFiles/diversity.0fold.sites", header = FALSE)
diversity.4fold = read.delim("/plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/4fold0fold.parsedVCFs/NucelotideDiversityFiles/diversity.4fold.sites", header = FALSE)

# Filter out duplicate sites
diversity.4fold.unique = unique(diversity.4fold[,c("V1","V2","V3","V4")])
diversity.0fold.unique = unique(diversity.0fold[,c("V1","V2","V3","V4")])

# Replace NA with 0
#diversity.4fold.unique$V4[diversity.4fold.unique$V4 == "NaN"] = 0
#diversity.0fold.unique$V4[diversity.0fold.unique$V4 == "NaN"] = 0

# Fix geneID column
diversity.4fold.unique$V4 = substr(diversity.4fold.unique$V4, 8,18)
diversity.0fold.unique$V4 = substr(diversity.0fold.unique$V4, 8,18)

colnames(diversity.4fold.unique) = c("Chrom", "Site", "Spi", "geneID")
colnames(diversity.0fold.unique) = c("Chrom", "Site", "Npi", "geneID")

diversity.4fold.per.gene$geneID = substr(diversity.4fold.per.gene$geneID, 8,18)
diversity.0fold.per.gene$geneID = substr(diversity.0fold.per.gene$geneID, 8,18)

# Summarize mean nucleotide diversity per gene
diversity.4fold.per.gene = summaryBy(pi ~ geneID, FUN = c(length, mean), data = diversity.4fold.unique)
diversity.0fold.per.gene = summaryBy(pi ~ geneID, FUN = c(length,mean), data = diversity.0fold.unique)

# Merge datasets
nucleotide.diversity.per.gene = merge(diversity.4fold.per.gene,diversity.0fold.per.gene, by = "geneID")
colnames(nucleotide.diversity.per.gene) = c("geneID", "piS.sites","piS","piN.sites","piN")
# Calculate piN/piS
nucleotide.diversity.per.gene$piN.piS = nucleotide.diversity.per.gene$piN / nucleotide.diversity.per.gene$piS

write.table(nucleotide.diversity.per.gene, file = "/plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/4fold0fold.parsedVCFs/NucelotideDiversityFiles/nucleotide.diversity.per.gene.Aug10.txt", quote = F, sep = "\t", col.name = T, row.name = F)

# ---- R CODE ----


#######################################################################################################################################
######    Calculating Synonymous and Nonsynonymous Nucleotide Diversity in the DGRP at DEU Significant and Nonsignificant Genes  ######
#######################################################################################################################################

###### There are two analyses I did here. First, was ignoring differential gene expression while the second parses piN/piS by sex-bias in gene expression

#---- R CODE -----
rm(list=ls())

# Required packages
require(doBy)
require(ggplot2)
require(dplyr)

## Load in datasets

# Load in VEP output with 4-fold degenerate site identified
# vep.output = read.delim("/plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/DGRP.vep.output.with.degeneracy", header = TRUE)
# Load in pi calculations
pi.output = read.delim("/plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/4fold0fold.parsedVCFs/NucelotideDiversityFiles/nucleotide.diversity.per.gene.Aug10.txt", header = TRUE)
# Load in pi estimates obtained by Grace Lee
pi.lee.output = read.delim("GraceLee.table.txt", header = TRUE)
# Load in the Junctionseq outputs
junctionseq.results.body = read.table("/plas1/amardeep.singh/RNA.Seq.Data/JunctionSeq.Files/BodyOutput/Aug1.Body.OnlyallGenes.results.txt", header = TRUE, sep = "\t")
junctionseq.results.head = read.table("/plas1/amardeep.singh/RNA.Seq.Data/JunctionSeq.Files/HeadOutput/Aug1.Head.OnlyallGenes.results.txt", header = TRUE, sep = "\t")
# Load in differential gene expression data in the DGRP
expression.data.body = read.table("/plas1/amardeep.singh/RNA.Seq.Data/GeneExpression/RAL.DifferentialGeneExpression.body.txt", header = TRUE, sep = "\t")
expression.data.head = read.table("/plas1/amardeep.singh/RNA.Seq.Data/GeneExpression/RAL.DifferentialGeneExpression.head.txt", header = TRUE, sep = "\t")

## Clean up data files
# Remove sites where piS is 0
piNpiS.per.gene = pi.output[!(pi.output$piN.piS == "Inf"),]
# Remove unneeded columns from Lee pi estimates
pi.lee.output = pi.lee.output[,c(28, 14:19,27)]
colnames(pi.lee.output)[8] = "piN.piS"
# Remove sites where piS is 0
pi.lee.output = pi.lee.output[!(pi.lee.output$piN.piS == "Inf"),]


# Remove unnecessary columns from junctionseq file and any rows with no data
junctionseq.results.body = junctionseq.results.body[!(junctionseq.results.body$testable == FALSE),]
junctionseq.results.head = junctionseq.results.head[!(junctionseq.results.head$testable == FALSE),]
junctionseq.results.body = junctionseq.results.body[junctionseq.results.body$expr_male > 10 & junctionseq.results.body$expr_female > 10,]
junctionseq.results.head = junctionseq.results.head[junctionseq.results.head$expr_male > 10 & junctionseq.results.head$expr_female > 10,]
junctionseq.results.body = junctionseq.results.body[, c(2,23:25)]
junctionseq.results.head = junctionseq.results.head[, c(2,23:25)]
# Clean out unnecessary columns in gene expression data
expression.data.body = expression.data.body[,c(2,4)]
expression.data.head = expression.data.head[,c(3,5)]

## Calculate piN and piS per gene
# Merge the nucleotide diversity and VEP output files
#pi.vep.merge = merge(pi.output, vep.output, by.x = "Location", by.y = "Location")
# Clean out unnecessary columns
#pi.vep.merge = pi.vep.merge[, c(1,4,7,10,18)]
#pi.vep.merge.syn.sub = pi.vep.merge[pi.vep.merge$Degeneracy == 4,]
#pi.vep.merge.non.syn.sub = pi.vep.merge[pi.vep.merge$Degeneracy == 0,]
## Clean out any rows with "NA"
#pi.vep.merge.syn.sub = pi.vep.merge.syn.sub[!(is.na(pi.vep.merge.syn.sub$Degeneracy)),]
#pi.vep.merge.non.syn.sub = pi.vep.merge.non.syn.sub[!(is.na(pi.vep.merge.non.syn.sub$Degeneracy)),]

#pi.syn.per.gene = summaryBy(PI ~ Gene, FUN = c(mean), data = pi.vep.merge.syn.sub)
#pi.non.syn.per.gene = summaryBy(PI ~ Gene, FUN = c(mean), data = pi.vep.merge.non.syn.sub)
# Rename columns and then merge datafiles
#colnames(pi.syn.per.gene)[2] = "piS"
#colnames(pi.non.syn.per.gene)[2] = "piNS"
#piNpiS.per.gene = merge(pi.syn.per.gene,pi.non.syn.per.gene, by = "Gene")

## Assign significant genes from JunctionSeq output
# Assign significant hits
junctionseq.results.body$sig.hit = NA
junctionseq.results.body$sig.hit[junctionseq.results.body$geneWisePadj <= 0.01] = 1
junctionseq.results.body$sig.hit[!(junctionseq.results.body$geneWisePadj <= 0.01)] = 0

junctionseq.results.head$sig.hit = NA
junctionseq.results.head$sig.hit[junctionseq.results.head$geneWisePadj <= 0.01] = 1
junctionseq.results.head$sig.hit[!(junctionseq.results.head$geneWisePadj <= 0.01)] = 0

# Collapse duplicates in Junctionseq files
junctionseq.results.body.unique = junctionseq.results.body[!duplicated(junctionseq.results.body[c(1,4:5)]), ]
junctionseq.results.head.unique = junctionseq.results.head[!duplicated(junctionseq.results.head[c(1,4:5)]), ]

# Merge piN/piS (my data) data with junctionseq data and add a column for the ratio of piN/piS
#body.pin.pis = merge(junctionseq.results.body.unique,piNpiS.per.gene, by.x = "geneID", by.y = "geneID", sort = FALSE)
#head.pin.pis = merge(junctionseq.results.head.unique,piNpiS.per.gene, by.x = "geneID", by.y = "geneID", sort = FALSE)

# Merge piN/piS (from Grace Lee) data with junctionseq data and add a column for the ratio of piN/piS
body.pin.pis = merge(junctionseq.results.body.unique,pi.lee.output, by.x = "geneID", by.y = "geneID", sort = FALSE)
head.pin.pis = merge(junctionseq.results.head.unique,pi.lee.output, by.x = "geneID", by.y = "geneID", sort = FALSE)

## Processing gene expression data
# Assign quantiles bins for male and female biased gene expression
male.biased.body = expression.data.body[expression.data.body$log2FoldChange > 0,]
female.biased.body = expression.data.body[expression.data.body$log2FoldChange < 0,]
male.biased.head = expression.data.head[expression.data.head$log2FoldChange > 0,]
female.biased.head = expression.data.head[expression.data.head$log2FoldChange < 0,]

# Remove any rows that have an NA added to them
male.biased.body = male.biased.body[!(is.na(male.biased.body$log2FoldChange)),]
female.biased.body = female.biased.body[!(is.na(female.biased.body$log2FoldChange)),]
male.biased.head = male.biased.head[!(is.na(male.biased.head$log2FoldChange)),]
female.biased.head = female.biased.head[!(is.na(female.biased.head$log2FoldChange)),]

# Assign quantile for both MBG and FBG
male.biased.body = male.biased.body %>% mutate(quantile = ntile(log2FoldChange, 4))
female.biased.body = female.biased.body %>% mutate(quantile = ntile(log2FoldChange, 4))
male.biased.head = male.biased.head %>% mutate(quantile = ntile(log2FoldChange, 4))
female.biased.head = female.biased.head %>% mutate(quantile = ntile(log2FoldChange, 4))

# For the male genes, lets add 4 to each quantile
male.biased.body$quantile = male.biased.body$quantile + 4
male.biased.head$quantile = male.biased.head$quantile + 4

# Merge data back
expression.data.body = rbind(male.biased.body,female.biased.body)
expression.data.head = rbind(male.biased.head,female.biased.head)

# Combining junctionseq/piNpiS data with gene expression data
body.pin.pis = merge(body.pin.pis, expression.data.body, by.x = "geneID" , by.y = "FlyBaseID", sort = FALSE)
head.pin.pis = merge(head.pin.pis, expression.data.head, by.x = "geneID" , by.y = "FlyBaseID", sort = FALSE)

## Summarizing data in expression quantiles
# Lets plot piNpiS for sig hits in quantile bins
body.sig.hits = body.pin.pis[body.pin.pis$sig.hit == 1,]
body.non.sig.hits = body.pin.pis[body.pin.pis$sig.hit == 0,]
head.sig.hits = head.pin.pis[head.pin.pis$sig.hit == 1,]
head.non.sig.hits = head.pin.pis[head.pin.pis$sig.hit == 0,]

# Determine mean nucleotide diversity in each quantile
body.sig.hits.mean = summaryBy(piN.piS ~ quantile, FUN=c(mean), data = body.sig.hits)
body.non.sig.hits.mean = summaryBy(piN.piS ~ quantile, FUN=c(mean), data = body.non.sig.hits)
head.sig.hits.mean = summaryBy(piN.piS ~ quantile, FUN=c(mean), data = head.sig.hits)
head.non.sig.hits.mean = summaryBy(piN.piS ~ quantile, FUN=c(mean), data = head.non.sig.hits)

##################
##    Ploting   ##
##################

### First plot is without parsing out by sex-bias in gene expression

# Combine head and body data into a single dataframe for plotting
body.pin.pis$tissue = "body"
head.pin.pis$tissue = "head"
pin.pis = rbind(body.pin.pis, head.pin.pis)

# Bootstrapping estimates of piN and piS as well as the ratio of piN:piS
body.piS_sig = vector(length = 10000, mode = "numeric")
body.piNS_sig = vector(length = 10000, mode = "numeric")
body.piN_piS_sig = vector(length = 10000, mode = "numeric")
body.piS_nonsig = vector(length = 10000, mode = "numeric")
body.piNS_nonsig = vector(length = 10000, mode = "numeric")
body.piN_piS_nonsig = vector(length = 10000, mode = "numeric")

head.piS_sig = vector(length = 10000, mode = "numeric")
head.piNS_sig = vector(length = 10000, mode = "numeric")
head.piN_piS_sig = vector(length = 10000, mode = "numeric")
head.piS_nonsig = vector(length = 10000, mode = "numeric")
head.piNS_nonsig = vector(length = 10000, mode = "numeric")
head.piN_piS_nonsig = vector(length = 10000, mode = "numeric")



## This loop will work when using my piN and piS values ## Use the loop below for estimates provided by Grace Lee
for (i in 1:10000){
  body.piS_sig[i] = mean(sample(x = body.pin.pis[body.pin.pis$sig.hit == 1,]$mean.pi.4fold.sites, size = length(body.pin.pis[body.pin.pis$sig.hit == 1,]$mean.pi.4fold.sites), replace = TRUE))
  body.piNS_sig[i] = mean(sample(x = body.pin.pis[body.pin.pis$sig.hit == 1,]$mean.pi.0fold.sites, size = length(body.pin.pis[body.pin.pis$sig.hit == 1,]$mean.pi.0fold.sites), replace = TRUE))
  body.piN_piS_sig[i] = mean(sample(x = body.pin.pis[body.pin.pis$sig.hit == 1,]$piN.piS, size = length(body.pin.pis[body.pin.pis$sig.hit == 1,]$piN.piS), replace = TRUE))
  body.piS_nonsig[i] = mean(sample(x = body.pin.pis[body.pin.pis$sig.hit == 1,]$mean.pi.4fold.sites, size = length(body.pin.pis[body.pin.pis$sig.hit == 0,]$mean.pi.4fold.sites), replace = TRUE))
  body.piNS_nonsig[i] = mean(sample(x = body.pin.pis[body.pin.pis$sig.hit == 1,]$mean.pi.0fold.sites, size = length(body.pin.pis[body.pin.pis$sig.hit == 0,]$mean.pi.0fold.sites), replace = TRUE))
  body.piN_piS_nonsig[i] = mean(sample(x = body.pin.pis[body.pin.pis$sig.hit == 1,]$piN.piS, size = length(body.pin.pis[body.pin.pis$sig.hit == 0,]$piN.piS), replace = TRUE))

  head.piS_sig[i] = mean(sample(x = head.pin.pis[head.pin.pis$sig.hit == 1,]$mean.pi.4fold.sites, size = length(head.pin.pis[head.pin.pis$sig.hit == 1,]$mean.pi.4fold.sites), replace = TRUE))
  head.piNS_sig[i] = mean(sample(x = head.pin.pis[head.pin.pis$sig.hit == 1,]$mean.pi.0fold.sites, size = length(head.pin.pis[head.pin.pis$sig.hit == 1,]$mean.pi.0fold.sites), replace = TRUE))
  head.piN_piS_sig[i] = mean(sample(x = head.pin.pis[head.pin.pis$sig.hit == 1,]$piN.piS, size = length(head.pin.pis[head.pin.pis$sig.hit == 1,]$piN.piS), replace = TRUE))
  head.piS_nonsig[i] = mean(sample(x = head.pin.pis[head.pin.pis$sig.hit == 1,]$mean.pi.4fold.sites, size = length(head.pin.pis[head.pin.pis$sig.hit == 0,]$mean.pi.4fold.sites), replace = TRUE))
  head.piNS_nonsig[i] = mean(sample(x = head.pin.pis[head.pin.pis$sig.hit == 1,]$mean.pi.0fold.sites, size = length(head.pin.pis[head.pin.pis$sig.hit == 0,]$mean.pi.0fold.sites), replace = TRUE))
  head.piN_piS_nonsig[i] = mean(sample(x = head.pin.pis[head.pin.pis$sig.hit == 1,]$piN.piS, size = length(head.pin.pis[head.pin.pis$sig.hit == 0,]$piN.piS), replace = TRUE))

  print(i)

}

## Loop to resample Grace Lee's estimates
for (i in 1:10000){
  body.piS_sig[i] = mean(sample(x = body.pin.pis[body.pin.pis$sig.hit == 1,]$Spi_RAL, size = length(body.pin.pis[body.pin.pis$sig.hit == 1,]$Spi_RAL), replace = TRUE))
  body.piNS_sig[i] = mean(sample(x = body.pin.pis[body.pin.pis$sig.hit == 1,]$Npi_RAL, size = length(body.pin.pis[body.pin.pis$sig.hit == 1,]$Npi_RAL), replace = TRUE))
  body.piN_piS_sig[i] = mean(sample(x = body.pin.pis[body.pin.pis$sig.hit == 1,]$piN.piS, size = length(body.pin.pis[body.pin.pis$sig.hit == 1,]$piN.piS), replace = TRUE))
  body.piS_nonsig[i] = mean(sample(x = body.pin.pis[body.pin.pis$sig.hit == 1,]$Spi_RAL, size = length(body.pin.pis[body.pin.pis$sig.hit == 0,]$Spi_RAL), replace = TRUE))
  body.piNS_nonsig[i] = mean(sample(x = body.pin.pis[body.pin.pis$sig.hit == 1,]$Npi_RAL, size = length(body.pin.pis[body.pin.pis$sig.hit == 0,]$Npi_RAL), replace = TRUE))
  body.piN_piS_nonsig[i] = mean(sample(x = body.pin.pis[body.pin.pis$sig.hit == 1,]$piN.piS, size = length(body.pin.pis[body.pin.pis$sig.hit == 0,]$piN.piS), replace = TRUE))

  head.piS_sig[i] = mean(sample(x = head.pin.pis[head.pin.pis$sig.hit == 1,]$Spi_RAL, size = length(head.pin.pis[head.pin.pis$sig.hit == 1,]$Spi_RAL), replace = TRUE))
  head.piNS_sig[i] = mean(sample(x = head.pin.pis[head.pin.pis$sig.hit == 1,]$Npi_RAL, size = length(head.pin.pis[head.pin.pis$sig.hit == 1,]$Npi_RAL), replace = TRUE))
  head.piN_piS_sig[i] = mean(sample(x = head.pin.pis[head.pin.pis$sig.hit == 1,]$piN.piS, size = length(head.pin.pis[head.pin.pis$sig.hit == 1,]$piN.piS), replace = TRUE))
  head.piS_nonsig[i] = mean(sample(x = head.pin.pis[head.pin.pis$sig.hit == 1,]$Spi_RAL, size = length(head.pin.pis[head.pin.pis$sig.hit == 0,]$Spi_RAL), replace = TRUE))
  head.piNS_nonsig[i] = mean(sample(x = head.pin.pis[head.pin.pis$sig.hit == 1,]$Npi_RAL, size = length(head.pin.pis[head.pin.pis$sig.hit == 0,]$Npi_RAL), replace = TRUE))
  head.piN_piS_nonsig[i] = mean(sample(x = head.pin.pis[head.pin.pis$sig.hit == 1,]$piN.piS, size = length(head.pin.pis[head.pin.pis$sig.hit == 0,]$piN.piS), replace = TRUE))

  print(i)

}


## <<< PLOTTING CODE HERE >>>>



#### Plotting by assessing piN/piS at genes showing DEU parsed by sex bias in gene expression


# Bootstrap means for each subset
# Body
body.sig.hits.quantile.1 = vector(mode = "numeric", length = 10000)
body.sig.hits.quantile.2 = vector(mode = "numeric", length = 10000)
body.sig.hits.quantile.3 = vector(mode = "numeric", length = 10000)
body.sig.hits.quantile.4 = vector(mode = "numeric", length = 10000)
body.sig.hits.quantile.5 = vector(mode = "numeric", length = 10000)
body.sig.hits.quantile.6 = vector(mode = "numeric", length = 10000)
body.sig.hits.quantile.7 = vector(mode = "numeric", length = 10000)
body.sig.hits.quantile.8 = vector(mode = "numeric", length = 10000)
body.non.sig.hits.quantile.1 = vector(mode = "numeric", length = 10000)
body.non.sig.hits.quantile.2 = vector(mode = "numeric", length = 10000)
body.non.sig.hits.quantile.3 = vector(mode = "numeric", length = 10000)
body.non.sig.hits.quantile.4 = vector(mode = "numeric", length = 10000)
body.non.sig.hits.quantile.5 = vector(mode = "numeric", length = 10000)
body.non.sig.hits.quantile.6 = vector(mode = "numeric", length = 10000)
body.non.sig.hits.quantile.7 = vector(mode = "numeric", length = 10000)
body.non.sig.hits.quantile.8 = vector(mode = "numeric", length = 10000)

# Head
head.sig.hits.quantile.1 = vector(mode = "numeric", length = 10000)
head.sig.hits.quantile.2 = vector(mode = "numeric", length = 10000)
head.sig.hits.quantile.3 = vector(mode = "numeric", length = 10000)
head.sig.hits.quantile.4 = vector(mode = "numeric", length = 10000)
head.sig.hits.quantile.5 = vector(mode = "numeric", length = 10000)
head.sig.hits.quantile.6 = vector(mode = "numeric", length = 10000)
head.sig.hits.quantile.7 = vector(mode = "numeric", length = 10000)
head.sig.hits.quantile.8 = vector(mode = "numeric", length = 10000)
head.non.sig.hits.quantile.1 = vector(mode = "numeric", length = 10000)
head.non.sig.hits.quantile.2 = vector(mode = "numeric", length = 10000)
head.non.sig.hits.quantile.3 = vector(mode = "numeric", length = 10000)
head.non.sig.hits.quantile.4 = vector(mode = "numeric", length = 10000)
head.non.sig.hits.quantile.5 = vector(mode = "numeric", length = 10000)
head.non.sig.hits.quantile.6 = vector(mode = "numeric", length = 10000)
head.non.sig.hits.quantile.7 = vector(mode = "numeric", length = 10000)
head.non.sig.hits.quantile.8 = vector(mode = "numeric", length = 10000)

## This loop is for my piN piS estimates use the one below for Grace Lee's estimates
for (i in 1:10000){
  # Resample significant hits
  body.sig.hits.quantile.1[i] = mean(sample(body.sig.hits$piN.piS[body.sig.hits$quantile == 1], length(body.sig.hits$piN.piS[body.sig.hits$quantile == 1]), replace = TRUE))
  body.sig.hits.quantile.2[i] = mean(sample(body.sig.hits$piN.piS[body.sig.hits$quantile == 2], length(body.sig.hits$piN.piS[body.sig.hits$quantile == 2]), replace = TRUE))
  body.sig.hits.quantile.3[i] = mean(sample(body.sig.hits$piN.piS[body.sig.hits$quantile == 3], length(body.sig.hits$piN.piS[body.sig.hits$quantile == 3]), replace = TRUE))
  body.sig.hits.quantile.4[i] = mean(sample(body.sig.hits$piN.piS[body.sig.hits$quantile == 4], length(body.sig.hits$piN.piS[body.sig.hits$quantile == 4]), replace = TRUE))
  body.sig.hits.quantile.5[i] = mean(sample(body.sig.hits$piN.piS[body.sig.hits$quantile == 5], length(body.sig.hits$piN.piS[body.sig.hits$quantile == 5]), replace = TRUE))
  body.sig.hits.quantile.6[i] = mean(sample(body.sig.hits$piN.piS[body.sig.hits$quantile == 6], length(body.sig.hits$piN.piS[body.sig.hits$quantile == 6]), replace = TRUE))
  body.sig.hits.quantile.7[i] = mean(sample(body.sig.hits$piN.piS[body.sig.hits$quantile == 7], length(body.sig.hits$piN.piS[body.sig.hits$quantile == 7]), replace = TRUE))
  body.sig.hits.quantile.8[i] = mean(sample(body.sig.hits$piN.piS[body.sig.hits$quantile == 8], length(body.sig.hits$piN.piS[body.sig.hits$quantile == 8]), replace = TRUE))

  head.sig.hits.quantile.1[i] = mean(sample(head.sig.hits$piN.piS[head.sig.hits$quantile == 1], length(head.sig.hits$piN.piS[head.sig.hits$quantile == 1]), replace = TRUE))
  head.sig.hits.quantile.2[i] = mean(sample(head.sig.hits$piN.piS[head.sig.hits$quantile == 2], length(head.sig.hits$piN.piS[head.sig.hits$quantile == 2]), replace = TRUE))
  head.sig.hits.quantile.3[i] = mean(sample(head.sig.hits$piN.piS[head.sig.hits$quantile == 3], length(head.sig.hits$piN.piS[head.sig.hits$quantile == 3]), replace = TRUE))
  head.sig.hits.quantile.4[i] = mean(sample(head.sig.hits$piN.piS[head.sig.hits$quantile == 4], length(head.sig.hits$piN.piS[head.sig.hits$quantile == 4]), replace = TRUE))
  head.sig.hits.quantile.5[i] = mean(sample(head.sig.hits$piN.piS[head.sig.hits$quantile == 5], length(head.sig.hits$piN.piS[head.sig.hits$quantile == 5]), replace = TRUE))
  head.sig.hits.quantile.6[i] = mean(sample(head.sig.hits$piN.piS[head.sig.hits$quantile == 6], length(head.sig.hits$piN.piS[head.sig.hits$quantile == 6]), replace = TRUE))
  head.sig.hits.quantile.7[i] = mean(sample(head.sig.hits$piN.piS[head.sig.hits$quantile == 7], length(head.sig.hits$piN.piS[head.sig.hits$quantile == 7]), replace = TRUE))
  head.sig.hits.quantile.8[i] = mean(sample(head.sig.hits$piN.piS[head.sig.hits$quantile == 8], length(head.sig.hits$piN.piS[head.sig.hits$quantile == 8]), replace = TRUE))

  # Resample non significant hits
  body.non.sig.hits.quantile.1[i] = mean(sample(body.non.sig.hits$piN.piS[body.non.sig.hits$quantile == 1], length(body.non.sig.hits$piN.piS[body.non.sig.hits$quantile == 1]), replace = TRUE))
  body.non.sig.hits.quantile.2[i] = mean(sample(body.non.sig.hits$piN.piS[body.non.sig.hits$quantile == 2], length(body.non.sig.hits$piN.piS[body.non.sig.hits$quantile == 2]), replace = TRUE))
  body.non.sig.hits.quantile.3[i] = mean(sample(body.non.sig.hits$piN.piS[body.non.sig.hits$quantile == 3], length(body.non.sig.hits$piN.piS[body.non.sig.hits$quantile == 3]), replace = TRUE))
  body.non.sig.hits.quantile.4[i] = mean(sample(body.non.sig.hits$piN.piS[body.non.sig.hits$quantile == 4], length(body.non.sig.hits$piN.piS[body.non.sig.hits$quantile == 4]), replace = TRUE))
  body.non.sig.hits.quantile.5[i] = mean(sample(body.non.sig.hits$piN.piS[body.non.sig.hits$quantile == 5], length(body.non.sig.hits$piN.piS[body.non.sig.hits$quantile == 5]), replace = TRUE))
  body.non.sig.hits.quantile.6[i] = mean(sample(body.non.sig.hits$piN.piS[body.non.sig.hits$quantile == 6], length(body.non.sig.hits$piN.piS[body.non.sig.hits$quantile == 6]), replace = TRUE))
  body.non.sig.hits.quantile.7[i] = mean(sample(body.non.sig.hits$piN.piS[body.non.sig.hits$quantile == 7], length(body.non.sig.hits$piN.piS[body.non.sig.hits$quantile == 7]), replace = TRUE))
  body.non.sig.hits.quantile.8[i] = mean(sample(body.non.sig.hits$piN.piS[body.non.sig.hits$quantile == 8], length(body.non.sig.hits$piN.piS[body.non.sig.hits$quantile == 8]), replace = TRUE))

  head.non.sig.hits.quantile.1[i] = mean(sample(head.non.sig.hits$piN.piS[head.non.sig.hits$quantile == 1], length(head.non.sig.hits$piN.piS[head.non.sig.hits$quantile == 1]), replace = TRUE))
  head.non.sig.hits.quantile.2[i] = mean(sample(head.non.sig.hits$piN.piS[head.non.sig.hits$quantile == 2], length(head.non.sig.hits$piN.piS[head.non.sig.hits$quantile == 2]), replace = TRUE))
  head.non.sig.hits.quantile.3[i] = mean(sample(head.non.sig.hits$piN.piS[head.non.sig.hits$quantile == 3], length(head.non.sig.hits$piN.piS[head.non.sig.hits$quantile == 3]), replace = TRUE))
  head.non.sig.hits.quantile.4[i] = mean(sample(head.non.sig.hits$piN.piS[head.non.sig.hits$quantile == 4], length(head.non.sig.hits$piN.piS[head.non.sig.hits$quantile == 4]), replace = TRUE))
  head.non.sig.hits.quantile.5[i] = mean(sample(head.non.sig.hits$piN.piS[head.non.sig.hits$quantile == 5], length(head.non.sig.hits$piN.piS[head.non.sig.hits$quantile == 5]), replace = TRUE))
  head.non.sig.hits.quantile.6[i] = mean(sample(head.non.sig.hits$piN.piS[head.non.sig.hits$quantile == 6], length(head.non.sig.hits$piN.piS[head.non.sig.hits$quantile == 6]), replace = TRUE))
  head.non.sig.hits.quantile.7[i] = mean(sample(head.non.sig.hits$piN.piS[head.non.sig.hits$quantile == 7], length(head.non.sig.hits$piN.piS[head.non.sig.hits$quantile == 7]), replace = TRUE))
  head.non.sig.hits.quantile.8[i] = mean(sample(head.non.sig.hits$piN.piS[head.non.sig.hits$quantile == 8], length(head.non.sig.hits$piN.piS[head.non.sig.hits$quantile == 8]), replace = TRUE))

print (i)
}

body.lower.CI = as.vector( c(  quantile(body.sig.hits.quantile.1, 0.05)[1],
                          quantile(body.sig.hits.quantile.2, 0.05)[1],
                          quantile(body.sig.hits.quantile.3, 0.05)[1],
                          quantile(body.sig.hits.quantile.4, 0.05)[1],
                          quantile(body.sig.hits.quantile.5, 0.05)[1],
                          quantile(body.sig.hits.quantile.6, 0.05)[1],
                          quantile(body.sig.hits.quantile.7, 0.05)[1],
                          quantile(body.sig.hits.quantile.8, 0.05)[1],
                          quantile(body.non.sig.hits.quantile.1, 0.05)[1],
                          quantile(body.non.sig.hits.quantile.2, 0.05)[1],
                          quantile(body.non.sig.hits.quantile.3, 0.05)[1],
                          quantile(body.non.sig.hits.quantile.4, 0.05)[1],
                          quantile(body.non.sig.hits.quantile.5, 0.05)[1],
                          quantile(body.non.sig.hits.quantile.6, 0.05)[1],
                          quantile(body.non.sig.hits.quantile.7, 0.05)[1],
                          quantile(body.non.sig.hits.quantile.8, 0.05)[1]))

body.upper.CI = as.vector( c( quantile(body.sig.hits.quantile.1, 0.95)[1],
                         quantile(body.sig.hits.quantile.2, 0.95)[1],
                         quantile(body.sig.hits.quantile.3, 0.95)[1],
                         quantile(body.sig.hits.quantile.4, 0.95)[1],
                         quantile(body.sig.hits.quantile.5, 0.95)[1],
                         quantile(body.sig.hits.quantile.6, 0.95)[1],
                         quantile(body.sig.hits.quantile.7, 0.95)[1],
                         quantile(body.sig.hits.quantile.8, 0.95)[1],
                         quantile(body.non.sig.hits.quantile.1, 0.95)[1],
                         quantile(body.non.sig.hits.quantile.2, 0.95)[1],
                         quantile(body.non.sig.hits.quantile.3, 0.95)[1],
                         quantile(body.non.sig.hits.quantile.4, 0.95)[1],
                         quantile(body.non.sig.hits.quantile.5, 0.95)[1],
                         quantile(body.non.sig.hits.quantile.6, 0.95)[1],
                         quantile(body.non.sig.hits.quantile.7, 0.95)[1],
                         quantile(body.non.sig.hits.quantile.8, 0.95)[1]))

#
head.lower.CI = as.vector( c(  quantile(head.sig.hits.quantile.1, 0.05)[1],
                          quantile(head.sig.hits.quantile.2, 0.05)[1],
                          quantile(head.sig.hits.quantile.3, 0.05)[1],
                          quantile(head.sig.hits.quantile.4, 0.05)[1],
                          quantile(head.sig.hits.quantile.5, 0.05)[1],
                          quantile(head.sig.hits.quantile.6, 0.05)[1],
                          quantile(head.sig.hits.quantile.7, 0.05)[1],
                          quantile(head.sig.hits.quantile.8, 0.05)[1],
                          quantile(head.non.sig.hits.quantile.1, 0.05)[1],
                          quantile(head.non.sig.hits.quantile.2, 0.05)[1],
                          quantile(head.non.sig.hits.quantile.3, 0.05)[1],
                          quantile(head.non.sig.hits.quantile.4, 0.05)[1],
                          quantile(head.non.sig.hits.quantile.5, 0.05)[1],
                          quantile(head.non.sig.hits.quantile.6, 0.05)[1],
                          quantile(head.non.sig.hits.quantile.7, 0.05)[1],
                          quantile(head.non.sig.hits.quantile.8, 0.05)[1]))

head.upper.CI = as.vector( c( quantile(head.sig.hits.quantile.1, 0.95)[1],
                         quantile(head.sig.hits.quantile.2, 0.95)[1],
                         quantile(head.sig.hits.quantile.3, 0.95)[1],
                         quantile(head.sig.hits.quantile.4, 0.95)[1],
                         quantile(head.sig.hits.quantile.5, 0.95)[1],
                         quantile(head.sig.hits.quantile.6, 0.95)[1],
                         quantile(head.sig.hits.quantile.7, 0.95)[1],
                         quantile(head.sig.hits.quantile.8, 0.95)[1],
                         quantile(head.non.sig.hits.quantile.1, 0.95)[1],
                         quantile(head.non.sig.hits.quantile.2, 0.95)[1],
                         quantile(head.non.sig.hits.quantile.3, 0.95)[1],
                         quantile(head.non.sig.hits.quantile.4, 0.95)[1],
                         quantile(head.non.sig.hits.quantile.5, 0.95)[1],
                         quantile(head.non.sig.hits.quantile.6, 0.95)[1],
                         quantile(head.non.sig.hits.quantile.7, 0.95)[1],
                         quantile(head.non.sig.hits.quantile.8, 0.95)[1]))


# Construct dataframes to hold all of our data for plotting
# Body
expression.quantile = rep(seq(1:8),2)
body.piN_piS.mean = c(body.sig.hits.mean$piN.piS.mean, body.non.sig.hits.mean$piN.piS.mean)
body.piN_piS.lowerCI = body.lower.CI
body.piN_piS.upperCI = body.upper.CI
body.piN_piS.df = as.data.frame(cbind(as.factor(expression.quantile), as.numeric(body.piN_piS.mean), as.numeric(body.piN_piS.lowerCI), as.numeric(body.piN_piS.upperCI)))
body.piN_piS.df$hit = as.factor(rep(c("sig","non.sig"), each=8))
body.piN_piS.df$tissue = as.factor("body")
colnames(body.piN_piS.df) = c("expression.quantile", "piN_piS.mean", "piN_piS.lowerCI", "piN_piS.upperCI", "hit", "tissue")

# head
expression.quantile = rep(seq(1:8),2)
head.piN_piS.mean = c(head.sig.hits.mean$piN.piS.mean, head.non.sig.hits.mean$piN.piS.mean)
head.piN_piS.lowerCI = head.lower.CI
head.piN_piS.upperCI = head.upper.CI
head.piN_piS.df = as.data.frame(cbind(as.factor(expression.quantile), as.numeric(head.piN_piS.mean), as.numeric(head.piN_piS.lowerCI), as.numeric(head.piN_piS.upperCI)))
head.piN_piS.df$hit = as.factor(rep(c("sig","non.sig"), each=8))
head.piN_piS.df$tissue = as.factor("head")
colnames(head.piN_piS.df) = c("expression.quantile", "piN_piS.mean", "piN_piS.lowerCI", "piN_piS.upperCI", "hit", "tissue")

## Combined plots
piN_piS.df = rbind(body.piN_piS.df, head.piN_piS.df)

## Body piN/piS plot

body.piN_piS.expression.plot = ggplot(body.piN_piS.df, aes(y = piN_piS.mean, x = as.factor(expression.quantile), colour = as.factor(hit))) +
                                      geom_point(aes(x = as.factor(expression.quantile), y = piN_piS.mean, colour = as.factor(hit)),size = 10,
                                      position = position_dodge(width = 0.5)) + ylim(0,0.3) +
                                      geom_errorbar(aes(ymin = piN_piS.lowerCI, ymax = piN_piS.upperCI, x = as.factor(expression.quantile), colour=as.factor(hit)),
                                      width = 0, position = position_dodge(width = 0.5)) + #geom_hline(yintercept = 1) +
                                      theme_bw() + scale_colour_manual(values = c("#7294D4", "#5B1A18")) +
                                      theme(panel.grid.major=element_blank(), panel.grid.minor=element_blank(),
                                            panel.border = element_rect(colour = "black", fill=NA, size=1),
                                            axis.text = element_text(face="bold", color="black",size=40, family = "Helvetica"),
                                            axis.title=element_blank()) #, legend.position = "none")
pdf("/plas1/amardeep.singh/tmp/body.piN_piS.expression.plot.pdf")
body.piN_piS.expression.plot
dev.off()


body.piN_piS.expression.plot

## Head piN/piS plot

head.piN_piS.expression.plot = ggplot(head.piN_piS.df, aes(y = piN_piS.mean, x = as.factor(expression.quantile), colour = as.factor(hit))) +
                                      geom_point(aes(x = as.factor(expression.quantile), y = piN_piS.mean, colour = as.factor(hit)),size = 10,
                                      position = position_dodge(width = 0.5)) + ylim(0,0.3) +
                                      geom_errorbar(aes(ymin = piN_piS.lowerCI, ymax = piN_piS.upperCI, x = as.factor(expression.quantile), colour=as.factor(hit)),
                                      width = 0, position = position_dodge(width = 0.5)) + #geom_hline(yintercept = 1) +
                                      theme_bw() + scale_colour_manual(values = c("#7294D4", "#5B1A18")) +
                                      theme(panel.grid.major=element_blank(), panel.grid.minor=element_blank(),
                                            panel.border = element_rect(colour = "black", fill=NA, size=1),
                                            axis.text = element_text(face="bold", color="black",size=40, family = "Helvetica"),
                                            axis.title=element_blank()) #, legend.position = "none")

pdf("/plas1/amardeep.singh/tmp/head.piN_piS.expression.plot.pdf")
head.piN_piS.expression.plot
dev.off()

## Head piN/piS plot
head.piN_piS.expression.plot = ggplot(head.piN_piS.df, aes(y = piN_piS.mean, x = as.factor(expression.quantile), colour = as.factor(hit))) +
                                      geom_point(aes(x = as.factor(expression.quantile), y = piN_piS.mean, colour = as.factor(hit)),size = 10,
                                      position = position_dodge(width = 0.5)) + ylim(0,0.3) +
                                      geom_errorbar(aes(ymin = piN_piS.lowerCI, ymax = piN_piS.upperCI, x = as.factor(expression.quantile), colour=as.factor(hit)),
                                      width = 0, position = position_dodge(width = 0.5)) + #geom_hline(yintercept = 1) +
                                      theme_bw() + scale_colour_manual(values = c("#7294D4", "#5B1A18")) +
                                      theme(panel.grid.major=element_blank(), panel.grid.minor=element_blank(),
                                            panel.border = element_rect(colour = "black", fill=NA, size=1),
                                            axis.text = element_text(face="bold", color="black",size=40, family = "Helvetica"),
                                            axis.title=element_blank(), legend.position = "none")
head.piN_piS.expression.plot

## Body/head piN/piS plot
piN_piS.expression.plot = ggplot(piN_piS.df, aes(y = piN_piS.mean, x = as.factor(expression.quantile), colour = as.factor(hit))) +
                                      geom_point(aes(x = as.factor(expression.quantile), y = piN_piS.mean, colour = as.factor(hit)),size = 10,
                                      position = position_dodge(width = 0.5)) + #scale_y_continuous(limits = c(-0.1, 0.1)) +
                                      geom_errorbar(aes(ymin = piN_piS.lowerCI, ymax = piN_piS.upperCI, x = as.factor(expression.quantile), colour=as.factor(hit)),
                                      width = 0.25, position = position_dodge(width = 0.5)) + geom_hline(yintercept = 1) +
                                      scale_colour_manual(values = c("#7294D4", "#5B1A18")) +
                                      theme_bw()  +
                                      theme(panel.grid.major=element_blank(), panel.grid.minor=element_blank(),
                                            panel.border = element_rect(colour = "black", fill=NA, size=1),
                                            axis.text = element_text(face="bold", color="black",size=20, family = "Helvetica"),
                                            axis.title=element_blank(), legend.position = "none") +
                                      facet_grid(tissue ~ .,  scales = "free")
piN_piS.expression.plot




############ O L D    C O D E     D O      N O T       U S E!! ########################

###################################################################################
######    Using Ensembl VEP to identify Synonymous and Nonsynonymous Sites   ######
###################################################################################

## Format the DGRP vcf file for VEP
cat /plas1/amardeep.singh/RNA.Seq.Data/DGRP.Genomic.Data/DGRP.filtered.vcf | awk 'BEGIN {OFS = FS = "\t"} { print $1 "\t" $2 "\t" $2 "\t" $4 "/" $5 "\t" "+" }' > DGRP.vcf.for.vep.tmp
# Remove header row
sed -i '/^#/d' DGRP.vcf.for.vep.tmp && mv DGRP.vcf.for.vep.tmp DGRP.vcf.for.vep
## I found this file had spaces in columns so I removed all delimeters and replaced them with tab
sed -i 's/  /:/g' DGRP.vcf.for.vep # Make sure that the the first space is a tab when running this
sed -i 's/ //g' DGRP.vcf.for.vep
sed -i 's/:/  /g' DGRP.vcf.for.vep # Make sure that the second space is a tab when running this

vep -i DGRP.vcf.for.vep -o DGRP.vep.output --species drosophila_melanogaster --cache --offline --stats_text --force_overwrite --distance 0 --coding_only &

## Identifying four-fold degenerate sites
R CMD BATCH 4FoldDegenerecy.from.VEP.output.R &










###### This deprecated method was done by using synonymous variants as synonymous sites  #####

## Calculate piN and piS per gene
# Merge the nucleotide diversity and VEP output files
pi.vep.merge = merge(pi.output, vep.output, by.x = "site", by.y = "Location")
# Clean out unnecessary columns
pi.vep.merge = pi.vep.merge[, c(1,4,7,10)]
pi.vep.merge.syn.sub = pi.vep.merge[pi.vep.merge$Consequence == "synonymous_variant",]
pi.vep.merge.non.syn.sub = pi.vep.merge[pi.vep.merge$Consequence != "synonymous_variant",]

pi.syn.per.gene = summaryBy(PI ~ Gene, FUN = c(mean), data = pi.vep.merge.syn.sub)
pi.non.syn.per.gene = summaryBy(PI ~ Gene, FUN = c(mean), data = pi.vep.merge.non.syn.sub)
# Rename columns and then merge datafiles
colnames(pi.syn.per.gene)[2] = "piS"
colnames(pi.non.syn.per.gene)[2] = "piNS"
piNpiS.per.gene = merge(pi.syn.per.gene,pi.non.syn.per.gene, by = "Gene")

## Assign significant genes from JunctionSeq output
# Assign significant hits
junctionseq.results.body$sig.hit = NA
junctionseq.results.body$sig.hit[junctionseq.results.body$geneWisePadj <= 0.01] = 1
junctionseq.results.body$sig.hit[!(junctionseq.results.body$geneWisePadj <= 0.01)] = 0

junctionseq.results.head$sig.hit = NA
junctionseq.results.head$sig.hit[junctionseq.results.head$geneWisePadj <= 0.01] = 1
junctionseq.results.head$sig.hit[!(junctionseq.results.head$geneWisePadj <= 0.01)] = 0

# Collapse duplicates in Junctionseq files
junctionseq.results.body.unique = junctionseq.results.body[!duplicated(junctionseq.results.body[c(1,4:5)]), ]
junctionseq.results.head.unique = junctionseq.results.head[!duplicated(junctionseq.results.head[c(1,4:5)]), ]

# Merge piN/piS data with junctionseq data
body.pin.pis = merge(junctionseq.results.body.unique,piNpiS.per.gene, by.x = "geneID", by.y = "Gene", sort = FALSE)
head.pin.pis = merge(junctionseq.results.head.unique,piNpiS.per.gene, by.x = "geneID", by.y = "Gene", sort = FALSE)



### Plotting piN and piS





#
