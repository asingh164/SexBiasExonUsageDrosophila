Assigning#
###################################################################
###################################################################
#####               p i N   /   p i S   Analysis              #####
###################################################################
###################################################################

###############################################################
######    Generating VCFs from Multifasta (.fas) files   ######
###############################################################

# This code assumes you have generated the multifasta files for each chromosome arm (see 'DGRP.Processing.txt')

# Making VCF files that contain both variant and invariant sites from .fas  multi-alignment files
~/apps/snp-sites/bin/snp-sites -v -b -o ChrX.variant.and.invariant.vcf ChrX.fas &
~/apps/snp-sites/bin/snp-sites -v -b -o Chr2L.variant.and.invariant.vcf Chr2L.fas &
~/apps/snp-sites/bin/snp-sites -v -b -o Chr2R.variant.and.invariant.vcf Chr2R.fas &
~/apps/snp-sites/bin/snp-sites -v -b -o Chr3L.variant.and.invariant.vcf Chr3L.fas &
~/apps/snp-sites/bin/snp-sites -v -b -o Chr3R.variant.and.invariant.vcf Chr3R.fas &


#######################################################################
######    Generating lists of 0fold and 4fold degenerate sites   ######
#######################################################################

# Run the 'DegeneracyScript' provided by Tyler Kent
# The code can be run as a bash script but I just ran each step separately so make sure to modify the input/output files
#   and make sure all your files are where they need to be

# Extract coordinates for each site (these bed files are 0-based and need to be updated to 1-based to match the vcf files - just take the third field as the starting site)
cat DGRP.2L.bedout_0fold.bed | awk '{OFS = FS = "\t"} {print $1 ":" $2+1}' > DGRP.2L.bedout_0fold.coordinates &
cat DGRP.2L.bedout_4fold.bed | awk '{OFS = FS = "\t"} {print $1 ":" $2+1}' > DGRP.2L.bedout_4fold.coordinates &
cat DGRP.2R.bedout_0fold.bed | awk '{OFS = FS = "\t"} {print $1 ":" $2+1}' > DGRP.2R.bedout_0fold.coordinates &
cat DGRP.2R.bedout_4fold.bed | awk '{OFS = FS = "\t"} {print $1 ":" $2+1}' > DGRP.2R.bedout_4fold.coordinates &

cat DGRP.3L.bedout_0fold.bed | awk '{OFS = FS = "\t"} {print $1 ":" $2+1}' > DGRP.3L.bedout_0fold.coordinates &
cat DGRP.3L.bedout_4fold.bed | awk '{OFS = FS = "\t"} {print $1 ":" $2+1}' > DGRP.3L.bedout_4fold.coordinates &
cat DGRP.3R.bedout_0fold.bed | awk '{OFS = FS = "\t"} {print $1 ":" $2+1}' > DGRP.3R.bedout_0fold.coordinates &
cat DGRP.3R.bedout_4fold.bed | awk '{OFS = FS = "\t"} {print $1 ":" $2+1}' > DGRP.3R.bedout_4fold.coordinates &

cat DGRP.X.bedout_0fold.bed | awk '{OFS = FS = "\t"} {print $1 ":" $2+1}' > DGRP.X.bedout_0fold.coordinates &
cat DGRP.X.bedout_4fold.bed | awk '{OFS = FS = "\t"} {print $1 ":" $2+1}' > DGRP.X.bedout_4fold.coordinates &


##################################################################################################################
######   Parse out vcf files into one containing only 0fold sites and another containing only 4fold sites   ######
##################################################################################################################

## Clean up vcf files
# Redirect header to attach to VCF later
cat Chr2L.variant.and.invariant.vcf | grep '#' > vcf.header
# Remove headers from vcf files
sed -i '/^#/d' *variant.and.invariant.vcf
# Replace Chromosome column with proper ID
cat Chr2L.variant.and.invariant.vcf | awk -F"\t" '{OFS=FS}{ $1="2L" ; print   }' > Chr2L.tmp && mv Chr2L.tmp Chr2L.variant.and.invariant.vcf &
cat Chr2R.variant.and.invariant.vcf | awk -F"\t" '{OFS=FS}{ $1="2R" ; print   }' > Chr2R.tmp && mv Chr2R.tmp Chr2R.variant.and.invariant.vcf &
cat Chr3L.variant.and.invariant.vcf | awk -F"\t" '{OFS=FS}{ $1="3L" ; print   }' > Chr3L.tmp && mv Chr3L.tmp Chr3L.variant.and.invariant.vcf &
cat Chr2R.variant.and.invariant.vcf | awk -F"\t" '{OFS=FS}{ $1="3R" ; print   }' > Chr3R.tmp && mv Chr3R.tmp Chr3R.variant.and.invariant.vcf &
cat ChrX.variant.and.invariant.vcf | awk -F"\t" '{OFS=FS}{ $1="X" ; print   }' > ChrX.tmp && mv ChrX.tmp ChrX.variant.and.invariant.vcf &

# Adding a unique ID column that will be used to clean out sites that don't match the 4fold and 0fold degenerate sites list
cat Chr2L.variant.and.invariant.vcf | awk '{print $1 ":" $2}' | paste - Chr2L.variant.and.invariant.vcf > Chr2L.variant.and.invariant.vcf.tmp &
cat Chr2R.variant.and.invariant.vcf | awk '{print $1 ":" $2}' | paste - Chr2R.variant.and.invariant.vcf > Chr2R.variant.and.invariant.vcf.tmp &
cat Chr3L.variant.and.invariant.vcf | awk '{print $1 ":" $2}' | paste - Chr3L.variant.and.invariant.vcf > Chr3L.variant.and.invariant.vcf.tmp &
cat Chr3R.variant.and.invariant.vcf | awk '{print $1 ":" $2}' | paste - Chr3R.variant.and.invariant.vcf > Chr3R.variant.and.invariant.vcf.tmp &
cat ChrX.variant.and.invariant.vcf | awk '{print $1 ":" $2}' | paste - ChrX.variant.and.invariant.vcf > ChrX.variant.and.invariant.vcf.tmp &

# Remove sites with no genotypic information
sed -i '/N/d' Chr2L.variant.and.invariant.vcf.tmp &
sed -i '/N/d' Chr2R.variant.and.invariant.vcf.tmp &
sed -i '/N/d' Chr3L.variant.and.invariant.vcf.tmp &
sed -i '/N/d' Chr3R.variant.and.invariant.vcf.tmp &
sed -i '/N/d' ChrX.variant.and.invariant.vcf.tmp &

# Compare to 4fold and 0fold coordinate sites to generate parsed VCFs for each type of variant 
grep -w -F -f /plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/TylersCode/bedOut/DGRP.2L.bedout_0fold.coordinates Chr2L.variant.and.invariant.vcf.tmp > /plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/4fold0fold.parsedVCFs/Chr2L.0fold.vcf &
grep -w -F -f /plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/TylersCode/bedOut/DGRP.2L.bedout_4fold.coordinates Chr2L.variant.and.invariant.vcf.tmp > /plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/4fold0fold.parsedVCFs/Chr2L.4fold.vcf &
grep -w -F -f /plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/TylersCode/bedOut/DGRP.2R.bedout_0fold.coordinates Chr2R.variant.and.invariant.vcf.tmp > /plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/4fold0fold.parsedVCFs/Chr2R.0fold.vcf &
grep -w -F -f /plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/TylersCode/bedOut/DGRP.2R.bedout_4fold.coordinates Chr2R.variant.and.invariant.vcf.tmp > /plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/4fold0fold.parsedVCFs/Chr2R.4fold.vcf &

grep -w -F -f /plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/TylersCode/bedOut/DGRP.3L.bedout_0fold.coordinates Chr3L.variant.and.invariant.vcf.tmp > /plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/4fold0fold.parsedVCFs/Chr3L.0fold.vcf &
grep -w -F -f /plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/TylersCode/bedOut/DGRP.3L.bedout_4fold.coordinates Chr3L.variant.and.invariant.vcf.tmp > /plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/4fold0fold.parsedVCFs/Chr3L.4fold.vcf &
grep -w -F -f /plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/TylersCode/bedOut/DGRP.3R.bedout_0fold.coordinates Chr3R.variant.and.invariant.vcf.tmp > /plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/4fold0fold.parsedVCFs/Chr3R.0fold.vcf &
grep -w -F -f /plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/TylersCode/bedOut/DGRP.3R.bedout_4fold.coordinates Chr3R.variant.and.invariant.vcf.tmp > /plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/4fold0fold.parsedVCFs/Chr3R.4fold.vcf &

grep -w -F -f /plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/TylersCode/bedOut/DGRP.X.bedout_0fold.coordinates ChrX.variant.and.invariant.vcf.tmp > /plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/4fold0fold.parsedVCFs/ChrX.0fold.vcf &
grep -w -F -f /plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/TylersCode/bedOut/DGRP.X.bedout_4fold.coordinates ChrX.variant.and.invariant.vcf.tmp > /plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/4fold0fold.parsedVCFs/ChrX.4fold.vcf &

## Remove ID column before processing VCF
cat Chr2L.0fold.vcf | cut -f 2-$NF > Chr2L.0fold.vcf.tmp && mv Chr2L.0fold.vcf.tmp Chr2L.0fold.vcf &
cat Chr2L.4fold.vcf | cut -f 2-$NF > Chr2L.4fold.vcf.tmp && mv Chr2L.4fold.vcf.tmp Chr2L.4fold.vcf &
cat Chr2R.0fold.vcf | cut -f 2-$NF > Chr2R.0fold.vcf.tmp && mv Chr2R.0fold.vcf.tmp Chr2R.0fold.vcf &
cat Chr2R.4fold.vcf | cut -f 2-$NF > Chr2R.4fold.vcf.tmp && mv Chr2R.4fold.vcf.tmp Chr2R.4fold.vcf &
cat Chr3L.0fold.vcf | cut -f 2-$NF > Chr3L.0fold.vcf.tmp && mv Chr3L.0fold.vcf.tmp Chr3L.0fold.vcf &
cat Chr3L.4fold.vcf | cut -f 2-$NF > Chr3L.4fold.vcf.tmp && mv Chr3L.4fold.vcf.tmp Chr3L.4fold.vcf &
cat Chr3R.0fold.vcf | cut -f 2-$NF > Chr3R.0fold.vcf.tmp && mv Chr3R.0fold.vcf.tmp Chr3R.0fold.vcf &
cat Chr3R.4fold.vcf | cut -f 2-$NF > Chr3R.4fold.vcf.tmp && mv Chr3R.4fold.vcf.tmp Chr3R.4fold.vcf &
cat ChrX.0fold.vcf | cut -f 2-$NF > ChrX.0fold.vcf.tmp && mv ChrX.0fold.vcf.tmp ChrX.0fold.vcf &
cat ChrX.4fold.vcf | cut -f 2-$NF > ChrX.4fold.vcf.tmp && mv ChrX.4fold.vcf.tmp ChrX.4fold.vcf &

##########################################################
### Convert SNP-sits VCF format to "Normal VCF" format ###    ## I forked this code form Ruzicka et al 2019 PLoS Bio
##########################################################

## Modify this code before running it! - Tell R which VCF to work with

#----- R code -----
rm(list=ls())
require(matrixStats)

## Modify VCF for Tajima's D analysis (r5 coordinates + remove positions where depth<20)

## Import vcf files of interest ## Need to change these two depending on the specific file
chr.vcf <- read.table("/plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/4fold0fold.parsedVCFs/ChrX.4fold.vcf")
print("Chromosome Loaded!")
output.name = "chr.X.4fold"
chr.number = "X"

#Sanity check
#plot(rownames(test.vcf),test.vcf$V2)

#Three possible types of acceptable allele
#No missing values
type1 <- c("A","T","G","C")
part1 <- subset(chr.vcf,V5 %in% type1)
if (nrow(part1) > 0) {
part1[part1==1] <- "1/1"
part1[part1==0] <- "0/0"
}

#Missing value = 2
type2 <- c("A,*","T,*","G,*","C,*")
part2 <- subset(chr.vcf,V5 %in% type2)
if (nrow(part2) > 0) {
part2[part2==2] <- "N/N"
part2[part2==1] <- "1/1"
part2[part2==0] <- "0/0" }
part2$V5 <- ifelse(part2$V5=="A,*","A",ifelse(part2$V5=="T,*","T",ifelse(part2$V5=="C,*","C",ifelse(part2$V5=="G,*","G",NA))))

#Missing value = 1
type3 <- c("*,A","*,T","*,G","*,C")
part3 <- subset(chr.vcf,V5 %in% type3)
if (nrow(part3) > 0) {
part3[part3==2] <- "1/1"
part3[part3==1] <- "N/N"
part3[part3==0] <- "0/0"
part3$V5 <- ifelse(part3$V5=="*,A","A",ifelse(part3$V5=="*,T","T",ifelse(part3$V5=="*,C","C",ifelse(part3$V5=="*,G","G",NA))))
}

#Missing value = none, i.e., this site is monomorphic
type4 <- c("*")
part4 <- subset(chr.vcf,V5 %in% type4)
if (nrow(part4) > 0) {
part4[part4==0] <- "1/1"
part4[part4==1] <- "N/N"
part4$V5 <- "."
}

#Rbind parts 1,2,3,4
vcf <- rbind(part1,part2,part3,part4)
#Transform position column to numeric
vcf$V2 <- as.numeric(vcf$V2)
#Order by position column
vcf <- vcf[order(vcf$V2),]
#Replace chromosome column with 1
vcf$V1 <- chr.number
#Filter for depth (DP>19)
vcf <- subset(vcf,rowCounts(vcf[,10:ncol(vcf)]!="./.")>41) # This now removes any sites that have more than 20% missing data
vcf$V2 <- format(vcf$V2,scientific=F)

write.table(vcf, file = paste("/plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/4fold0fold.parsedVCFs/", output.name, "_modified.vcf", sep = ""), sep="\t",row.names = F, quote=F, col.names=F)

rm(list=ls())

# ---- /R Code ----

# Add header back to vcf files
cat vcf.header chr.2L.0fold_modified.vcf > chr.2L.0fold_modified.vcf.tmp && mv chr.2L.0fold_modified.vcf.tmp chr.2L.0fold_modified.vcf &
cat vcf.header chr.2L.4fold_modified.vcf > chr.2L.4fold_modified.vcf.tmp && mv chr.2L.4fold_modified.vcf.tmp chr.2L.4fold_modified.vcf &
cat vcf.header chr.2R.0fold_modified.vcf > chr.2R.0fold_modified.vcf.tmp && mv chr.2R.0fold_modified.vcf.tmp chr.2R.0fold_modified.vcf &
cat vcf.header chr.2R.4fold_modified.vcf > chr.2R.4fold_modified.vcf.tmp && mv chr.2R.4fold_modified.vcf.tmp chr.2R.4fold_modified.vcf &
cat vcf.header chr.3L.0fold_modified.vcf > chr.3L.0fold_modified.vcf.tmp && mv chr.3L.0fold_modified.vcf.tmp chr.3L.0fold_modified.vcf &
cat vcf.header chr.3L.4fold_modified.vcf > chr.3L.4fold_modified.vcf.tmp && mv chr.3L.4fold_modified.vcf.tmp chr.3L.4fold_modified.vcf &
cat vcf.header chr.3R.0fold_modified.vcf > chr.3R.0fold_modified.vcf.tmp && mv chr.3R.0fold_modified.vcf.tmp chr.3R.0fold_modified.vcf &
cat vcf.header chr.3R.4fold_modified.vcf > chr.3R.4fold_modified.vcf.tmp && mv chr.3R.4fold_modified.vcf.tmp chr.3R.4fold_modified.vcf &
cat vcf.header chr.X.0fold_modified.vcf > chr.X.0fold_modified.vcf.tmp && mv chr.X.0fold_modified.vcf.tmp chr.X.0fold_modified.vcf &
cat vcf.header chr.X.4fold_modified.vcf > chr.X.4fold_modified.vcf.tmp && mv chr.X.4fold_modified.vcf.tmp chr.X.4fold_modified.vcf &



#############################################################################################
######    Calculating Nucleotide Diversity in the DGRP and Assigning Sites to genes    ######
#############################################################################################

cat /plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/4fold0fold.parsedVCFs/chr.2L.4fold_modified.vcf | vcftools --vcf - --site-pi --out  Chr2L.4fold &
cat /plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/4fold0fold.parsedVCFs/chr.2L.0fold_modified.vcf | vcftools --vcf - --site-pi --out  Chr2L.0fold &
cat /plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/4fold0fold.parsedVCFs/chr.2R.4fold_modified.vcf | vcftools --vcf - --site-pi --out  Chr2R.4fold &
cat /plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/4fold0fold.parsedVCFs/chr.2R.0fold_modified.vcf | vcftools --vcf - --site-pi --out  Chr2R.0fold &
cat /plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/4fold0fold.parsedVCFs/chr.3L.4fold_modified.vcf | vcftools --vcf - --site-pi --out  Chr3L.4fold &
cat /plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/4fold0fold.parsedVCFs/chr.3L.0fold_modified.vcf | vcftools --vcf - --site-pi --out  Chr3L.0fold &
cat /plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/4fold0fold.parsedVCFs/chr.3R.4fold_modified.vcf | vcftools --vcf - --site-pi --out  Chr3R.4fold &
cat /plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/4fold0fold.parsedVCFs/chr.3R.0fold_modified.vcf | vcftools --vcf - --site-pi --out  Chr3R.0fold &
cat /plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/4fold0fold.parsedVCFs/chr.X.4fold_modified.vcf | vcftools --vcf - --site-pi --out  ChrX.4fold &
cat /plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/4fold0fold.parsedVCFs/chr.X.0fold_modified.vcf | vcftools --vcf - --site-pi --out  ChrX.0fold &

# I moved the output file to a folder where I kept the rest of the data generated in this script
mv *.pi NucelotideDiversityFiles/

###############################################################
######    Intersect    ######
###############################################################


###################################################################################
######    Using Ensembl VEP to identify Synonymous and Nonsynonymous Sites   ######
###################################################################################

## Format the DGRP vcf file for VEP
cat /plas1/amardeep.singh/RNA.Seq.Data/DGRP.Genomic.Data/DGRP.filtered.vcf | awk 'BEGIN {OFS = FS = "\t"} { print $1 "\t" $2 "\t" $2 "\t" $4 "/" $5 "\t" "+" }' > DGRP.vcf.for.vep.tmp
# Remove header row
sed -i '/^#/d' DGRP.vcf.for.vep.tmp && mv DGRP.vcf.for.vep.tmp DGRP.vcf.for.vep
## I found this file had spaces in columns so I removed all delimeters and replaced them with tab
sed -i 's/  /:/g' DGRP.vcf.for.vep # Make sure that the the first space is a tab when running this
sed -i 's/ //g' DGRP.vcf.for.vep
sed -i 's/:/  /g' DGRP.vcf.for.vep # Make sure that the second space is a tab when running this

vep -i DGRP.vcf.for.vep -o DGRP.vep.output --species drosophila_melanogaster --cache --offline --stats_text --force_overwrite --distance 0 --coding_only &

## Identifying four-fold degenerate sites
R CMD BATCH 4FoldDegenerecy.from.VEP.output.R &


#######################################################################################################################################
######    Calculating Synonymous and Nonsynonymous Nucleotide Diversity in the DGRP at DEU Significant and Nonsignificant Genes  ######
#######################################################################################################################################

###### There are two analyses I did here. First, was ignoring differential gene expression while the second parses piN/piS by sex-bias in gene expression

#---- R CODE -----
rm(list=ls())

# Required packages
require(doBy)
require(ggplot2)
require(dplyr)

## Load in datasets

# Load in VEP output with 4-fold degenerate site identified
vep.output = read.delim("/plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/DGRP.vep.output.with.degeneracy", header = TRUE)
# Load in pi calculations
pi.output = read.delim("/plas1/amardeep.singh/RNA.Seq.Data/piNpiS.Analysis/nucleotide_diversity.sites.pi", header = TRUE)
# Load in the Junctionseq outputs
junctionseq.results.body = read.table("/plas1/amardeep.singh/RNA.Seq.Data/JunctionSeq.Files/BodyOutput/Aug1.Body.OnlyallGenes.results.txt", header = TRUE, sep = "\t")
junctionseq.results.head = read.table("/plas1/amardeep.singh/RNA.Seq.Data/JunctionSeq.Files/HeadOutput/Aug1.Head.OnlyallGenes.results.txt", header = TRUE, sep = "\t")
# Load in differential gene expression data in the DGRP
expression.data.body = read.table("/plas1/amardeep.singh/RNA.Seq.Data/GeneExpression/RAL.DifferentialGeneExpression.body.txt", header = TRUE, sep = "\t")
expression.data.head = read.table("/plas1/amardeep.singh/RNA.Seq.Data/GeneExpression/RAL.DifferentialGeneExpression.head.txt", header = TRUE, sep = "\t")


## Clean up data files
# Add column for coordinates for pi file that follows the chr:xxxxx format
pi.output$Location = paste(pi.output$CHROM, pi.output$POS, sep = ":")
# Remove duplicate sites in vep output
vep.output = vep.output[!duplicated(vep.output[c(2:4,7)]), ]
# Remove unnecessary columns from junctionseq file and any rows with no data
junctionseq.results.body = junctionseq.results.body[!(junctionseq.results.body$testable == FALSE),]
junctionseq.results.head = junctionseq.results.head[!(junctionseq.results.head$testable == FALSE),]
junctionseq.results.body = junctionseq.results.body[junctionseq.results.body$expr_male > 10 & junctionseq.results.body$expr_female > 10,]
junctionseq.results.head = junctionseq.results.head[junctionseq.results.head$expr_male > 10 & junctionseq.results.head$expr_female > 10,]
junctionseq.results.body = junctionseq.results.body[, c(2,23:25)]
junctionseq.results.head = junctionseq.results.head[, c(2,23:25)]
# Clean out unnecessary columns in gene expression data
expression.data.body = expression.data.body[,c(2,4)]
expression.data.head = expression.data.head[,c(3,5)]

## Calculate piN and piS per gene
# Merge the nucleotide diversity and VEP output files
pi.vep.merge = merge(pi.output, vep.output, by.x = "Location", by.y = "Location")
# Clean out unnecessary columns
pi.vep.merge = pi.vep.merge[, c(1,4,7,10,18)]
pi.vep.merge.syn.sub = pi.vep.merge[pi.vep.merge$Degeneracy == 4,]
pi.vep.merge.non.syn.sub = pi.vep.merge[pi.vep.merge$Degeneracy == 0,]
# Clean out any rows with "NA"
pi.vep.merge.syn.sub = pi.vep.merge.syn.sub[!(is.na(pi.vep.merge.syn.sub$Degeneracy)),]
pi.vep.merge.non.syn.sub = pi.vep.merge.non.syn.sub[!(is.na(pi.vep.merge.non.syn.sub$Degeneracy)),]

pi.syn.per.gene = summaryBy(PI ~ Gene, FUN = c(mean), data = pi.vep.merge.syn.sub)
pi.non.syn.per.gene = summaryBy(PI ~ Gene, FUN = c(mean), data = pi.vep.merge.non.syn.sub)
# Rename columns and then merge datafiles
colnames(pi.syn.per.gene)[2] = "piS"
colnames(pi.non.syn.per.gene)[2] = "piNS"
piNpiS.per.gene = merge(pi.syn.per.gene,pi.non.syn.per.gene, by = "Gene")

## Assign significant genes from JunctionSeq output
# Assign significant hits
junctionseq.results.body$sig.hit = NA
junctionseq.results.body$sig.hit[junctionseq.results.body$geneWisePadj <= 0.01] = 1
junctionseq.results.body$sig.hit[!(junctionseq.results.body$geneWisePadj <= 0.01)] = 0

junctionseq.results.head$sig.hit = NA
junctionseq.results.head$sig.hit[junctionseq.results.head$geneWisePadj <= 0.01] = 1
junctionseq.results.head$sig.hit[!(junctionseq.results.head$geneWisePadj <= 0.01)] = 0

# Collapse duplicates in Junctionseq files
junctionseq.results.body.unique = junctionseq.results.body[!duplicated(junctionseq.results.body[c(1,4:5)]), ]
junctionseq.results.head.unique = junctionseq.results.head[!duplicated(junctionseq.results.head[c(1,4:5)]), ]

# Merge piN/piS data with junctionseq data and add a column for the ratio of piN/piS
body.pin.pis = merge(junctionseq.results.body.unique,piNpiS.per.gene, by.x = "geneID", by.y = "Gene", sort = FALSE)
head.pin.pis = merge(junctionseq.results.head.unique,piNpiS.per.gene, by.x = "geneID", by.y = "Gene", sort = FALSE)
body.pin.pis$piN_piS = body.pin.pis$piNS / body.pin.pis$piS
head.pin.pis$piN_piS = head.pin.pis$piNS / head.pin.pis$piS

## Processing gene expression data
# Assign quartile bins for male and female biased gene expression
male.biased.body = expression.data.body[expression.data.body$log2FoldChange > 0,]
female.biased.body = expression.data.body[expression.data.body$log2FoldChange < 0,]
male.biased.head = expression.data.head[expression.data.head$log2FoldChange > 0,]
female.biased.head = expression.data.head[expression.data.head$log2FoldChange < 0,]

# Remove any rows that have an NA added to them
male.biased.body = male.biased.body[!(is.na(male.biased.body$log2FoldChange)),]
female.biased.body = female.biased.body[!(is.na(female.biased.body$log2FoldChange)),]
male.biased.head = male.biased.head[!(is.na(male.biased.head$log2FoldChange)),]
female.biased.head = female.biased.head[!(is.na(female.biased.head$log2FoldChange)),]

# Assign quartiles for both MBG and FBG
male.biased.body = male.biased.body %>% mutate(quartile = ntile(log2FoldChange, 4))
female.biased.body = female.biased.body %>% mutate(quartile = ntile(log2FoldChange, 4))
male.biased.head = male.biased.head %>% mutate(quartile = ntile(log2FoldChange, 4))
female.biased.head = female.biased.head %>% mutate(quartile = ntile(log2FoldChange, 4))

# For the male genes, lets add 4 to each quartile
male.biased.body$quartile = male.biased.body$quartile + 4
male.biased.head$quartile = male.biased.head$quartile + 4

# Merge data back
expression.data.body = rbind(male.biased.body,female.biased.body)
expression.data.head = rbind(male.biased.head,female.biased.head)

# Combining junctionseq/piNpiS data with gene expression data
body.pin.pis = merge(body.pin.pis, expression.data.body, by.x = "geneID" , by.y = "FlyBaseID", sort = FALSE)
head.pin.pis = merge(head.pin.pis, expression.data.head, by.x = "geneID" , by.y = "FlyBaseID", sort = FALSE)

## Summarizing data in expression quartiles
# Lets plot piNpiS for sig hits in quartile bins
body.sig.hits = body.pin.pis[body.pin.pis$sig.hit == 1,]
body.non.sig.hits = body.pin.pis[body.pin.pis$sig.hit == 0,]
head.sig.hits = head.pin.pis[head.pin.pis$sig.hit == 1,]
head.non.sig.hits = head.pin.pis[head.pin.pis$sig.hit == 0,]

# Determine mean tajimasD in each quartile
body.sig.hits.mean = summaryBy(piN_piS ~ quartile, FUN=c(mean), data = body.sig.hits)
body.non.sig.hits.mean = summaryBy(piN_piS ~ quartile, FUN=c(mean), data = body.non.sig.hits)
head.sig.hits.mean = summaryBy(piN_piS ~ quartile, FUN=c(mean), data = head.sig.hits)
head.non.sig.hits.mean = summaryBy(piN_piS ~ quartile, FUN=c(mean), data = head.non.sig.hits)

##################
##    Ploting   ##
##################

### First plot is without parsing out by sex-bias in gene expression

# Combine head and body data into a single dataframe for plotting
body.pin.pis$tissue = "body"
head.pin.pis$tissue = "head"
pin.pis = rbind(body.pin.pis, head.pin.pis)

# Bootstrapping estimates of piN and piS as well as the ratio of piN:piS
body.piS_sig = vector(length = 10000, mode = "numeric")
body.piNS_sig = vector(length = 10000, mode = "numeric")
body.piN_piS_sig = vector(length = 10000, mode = "numeric")
body.piS_nonsig = vector(length = 10000, mode = "numeric")
body.piNS_nonsig = vector(length = 10000, mode = "numeric")
body.piN_piS_nonsig = vector(length = 10000, mode = "numeric")

head.piS_sig = vector(length = 10000, mode = "numeric")
head.piNS_sig = vector(length = 10000, mode = "numeric")
head.piN_piS_sig = vector(length = 10000, mode = "numeric")
head.piS_nonsig = vector(length = 10000, mode = "numeric")
head.piNS_nonsig = vector(length = 10000, mode = "numeric")
head.piN_piS_nonsig = vector(length = 10000, mode = "numeric")

for (i in 1:10000){
  body.piS_sig[i] = mean(sample(x = body.pin.pis[body.pin.pis$sig.hit == 1,]$piS, size = length(body.pin.pis[body.pin.pis$sig.hit == 1,]$piS), replace = TRUE))
  body.piNS_sig[i] = mean(sample(x = body.pin.pis[body.pin.pis$sig.hit == 1,]$piNS, size = length(body.pin.pis[body.pin.pis$sig.hit == 1,]$piNS), replace = TRUE))
  body.piN_piS_sig[i] = mean(sample(x = body.pin.pis[body.pin.pis$sig.hit == 1,]$piN_piS, size = length(body.pin.pis[body.pin.pis$sig.hit == 1,]$piN_piS), replace = TRUE))
  body.piS_nonsig[i] = mean(sample(x = body.pin.pis[body.pin.pis$sig.hit == 1,]$piS, size = length(body.pin.pis[body.pin.pis$sig.hit == 0,]$piS), replace = TRUE))
  body.piNS_nonsig[i] = mean(sample(x = body.pin.pis[body.pin.pis$sig.hit == 1,]$piNS, size = length(body.pin.pis[body.pin.pis$sig.hit == 0,]$piNS), replace = TRUE))
  body.piN_piS_nonsig[i] = mean(sample(x = body.pin.pis[body.pin.pis$sig.hit == 1,]$piN_piS, size = length(body.pin.pis[body.pin.pis$sig.hit == 0,]$piN_piS), replace = TRUE))

  head.piS_sig[i] = mean(sample(x = head.pin.pis[head.pin.pis$sig.hit == 1,]$piS, size = length(head.pin.pis[head.pin.pis$sig.hit == 1,]$piS), replace = TRUE))
  head.piNS_sig[i] = mean(sample(x = head.pin.pis[head.pin.pis$sig.hit == 1,]$piNS, size = length(head.pin.pis[head.pin.pis$sig.hit == 1,]$piNS), replace = TRUE))
  head.piN_piS_sig[i] = mean(sample(x = head.pin.pis[head.pin.pis$sig.hit == 1,]$piN_piS, size = length(head.pin.pis[head.pin.pis$sig.hit == 1,]$piN_piS), replace = TRUE))
  head.piS_nonsig[i] = mean(sample(x = head.pin.pis[head.pin.pis$sig.hit == 1,]$piS, size = length(head.pin.pis[head.pin.pis$sig.hit == 0,]$piS), replace = TRUE))
  head.piNS_nonsig[i] = mean(sample(x = head.pin.pis[head.pin.pis$sig.hit == 1,]$piNS, size = length(head.pin.pis[head.pin.pis$sig.hit == 0,]$piNS), replace = TRUE))
  head.piN_piS_nonsig[i] = mean(sample(x = head.pin.pis[head.pin.pis$sig.hit == 1,]$piN_piS, size = length(head.pin.pis[head.pin.pis$sig.hit == 0,]$piN_piS), replace = TRUE))

  print(i)

}

#### Plotting by assessing piN/piS at genes showing DEU parsed by sex bias in gene expression


# Bootstrap means for each subset
# Body
body.sig.hits.quantile.1 = vector(mode = "numeric", length = 10000)
body.sig.hits.quantile.2 = vector(mode = "numeric", length = 10000)
body.sig.hits.quantile.3 = vector(mode = "numeric", length = 10000)
body.sig.hits.quantile.4 = vector(mode = "numeric", length = 10000)
body.sig.hits.quantile.5 = vector(mode = "numeric", length = 10000)
body.sig.hits.quantile.6 = vector(mode = "numeric", length = 10000)
body.sig.hits.quantile.7 = vector(mode = "numeric", length = 10000)
body.sig.hits.quantile.8 = vector(mode = "numeric", length = 10000)
body.non.sig.hits.quantile.1 = vector(mode = "numeric", length = 10000)
body.non.sig.hits.quantile.2 = vector(mode = "numeric", length = 10000)
body.non.sig.hits.quantile.3 = vector(mode = "numeric", length = 10000)
body.non.sig.hits.quantile.4 = vector(mode = "numeric", length = 10000)
body.non.sig.hits.quantile.5 = vector(mode = "numeric", length = 10000)
body.non.sig.hits.quantile.6 = vector(mode = "numeric", length = 10000)
body.non.sig.hits.quantile.7 = vector(mode = "numeric", length = 10000)
body.non.sig.hits.quantile.8 = vector(mode = "numeric", length = 10000)

# Head
head.sig.hits.quantile.1 = vector(mode = "numeric", length = 10000)
head.sig.hits.quantile.2 = vector(mode = "numeric", length = 10000)
head.sig.hits.quantile.3 = vector(mode = "numeric", length = 10000)
head.sig.hits.quantile.4 = vector(mode = "numeric", length = 10000)
head.sig.hits.quantile.5 = vector(mode = "numeric", length = 10000)
head.sig.hits.quantile.6 = vector(mode = "numeric", length = 10000)
head.sig.hits.quantile.7 = vector(mode = "numeric", length = 10000)
head.sig.hits.quantile.8 = vector(mode = "numeric", length = 10000)
head.non.sig.hits.quantile.1 = vector(mode = "numeric", length = 10000)
head.non.sig.hits.quantile.2 = vector(mode = "numeric", length = 10000)
head.non.sig.hits.quantile.3 = vector(mode = "numeric", length = 10000)
head.non.sig.hits.quantile.4 = vector(mode = "numeric", length = 10000)
head.non.sig.hits.quantile.5 = vector(mode = "numeric", length = 10000)
head.non.sig.hits.quantile.6 = vector(mode = "numeric", length = 10000)
head.non.sig.hits.quantile.7 = vector(mode = "numeric", length = 10000)
head.non.sig.hits.quantile.8 = vector(mode = "numeric", length = 10000)

for (i in 1:10000){
  # Resample significant hits
  body.sig.hits.quantile.1[i] = mean(sample(body.sig.hits$piN_piS[body.sig.hits$quartile == 1], length(body.sig.hits$piN_piS[body.sig.hits$quartile == 1]), replace = TRUE))
  body.sig.hits.quantile.2[i] = mean(sample(body.sig.hits$piN_piS[body.sig.hits$quartile == 2], length(body.sig.hits$piN_piS[body.sig.hits$quartile == 2]), replace = TRUE))
  body.sig.hits.quantile.3[i] = mean(sample(body.sig.hits$piN_piS[body.sig.hits$quartile == 3], length(body.sig.hits$piN_piS[body.sig.hits$quartile == 3]), replace = TRUE))
  body.sig.hits.quantile.4[i] = mean(sample(body.sig.hits$piN_piS[body.sig.hits$quartile == 4], length(body.sig.hits$piN_piS[body.sig.hits$quartile == 4]), replace = TRUE))
  body.sig.hits.quantile.5[i] = mean(sample(body.sig.hits$piN_piS[body.sig.hits$quartile == 5], length(body.sig.hits$piN_piS[body.sig.hits$quartile == 5]), replace = TRUE))
  body.sig.hits.quantile.6[i] = mean(sample(body.sig.hits$piN_piS[body.sig.hits$quartile == 6], length(body.sig.hits$piN_piS[body.sig.hits$quartile == 6]), replace = TRUE))
  body.sig.hits.quantile.7[i] = mean(sample(body.sig.hits$piN_piS[body.sig.hits$quartile == 7], length(body.sig.hits$piN_piS[body.sig.hits$quartile == 7]), replace = TRUE))
  body.sig.hits.quantile.8[i] = mean(sample(body.sig.hits$piN_piS[body.sig.hits$quartile == 8], length(body.sig.hits$piN_piS[body.sig.hits$quartile == 8]), replace = TRUE))

  head.sig.hits.quantile.1[i] = mean(sample(head.sig.hits$piN_piS[head.sig.hits$quartile == 1], length(head.sig.hits$piN_piS[head.sig.hits$quartile == 1]), replace = TRUE))
  head.sig.hits.quantile.2[i] = mean(sample(head.sig.hits$piN_piS[head.sig.hits$quartile == 2], length(head.sig.hits$piN_piS[head.sig.hits$quartile == 2]), replace = TRUE))
  head.sig.hits.quantile.3[i] = mean(sample(head.sig.hits$piN_piS[head.sig.hits$quartile == 3], length(head.sig.hits$piN_piS[head.sig.hits$quartile == 3]), replace = TRUE))
  head.sig.hits.quantile.4[i] = mean(sample(head.sig.hits$piN_piS[head.sig.hits$quartile == 4], length(head.sig.hits$piN_piS[head.sig.hits$quartile == 4]), replace = TRUE))
  head.sig.hits.quantile.5[i] = mean(sample(head.sig.hits$piN_piS[head.sig.hits$quartile == 5], length(head.sig.hits$piN_piS[head.sig.hits$quartile == 5]), replace = TRUE))
  head.sig.hits.quantile.6[i] = mean(sample(head.sig.hits$piN_piS[head.sig.hits$quartile == 6], length(head.sig.hits$piN_piS[head.sig.hits$quartile == 6]), replace = TRUE))
  head.sig.hits.quantile.7[i] = mean(sample(head.sig.hits$piN_piS[head.sig.hits$quartile == 7], length(head.sig.hits$piN_piS[head.sig.hits$quartile == 7]), replace = TRUE))
  head.sig.hits.quantile.8[i] = mean(sample(head.sig.hits$piN_piS[head.sig.hits$quartile == 8], length(head.sig.hits$piN_piS[head.sig.hits$quartile == 8]), replace = TRUE))

  # Resample non significant hits
  body.non.sig.hits.quantile.1[i] = mean(sample(body.non.sig.hits$piN_piS[body.non.sig.hits$quartile == 1], length(body.non.sig.hits$piN_piS[body.non.sig.hits$quartile == 1]), replace = TRUE))
  body.non.sig.hits.quantile.2[i] = mean(sample(body.non.sig.hits$piN_piS[body.non.sig.hits$quartile == 2], length(body.non.sig.hits$piN_piS[body.non.sig.hits$quartile == 2]), replace = TRUE))
  body.non.sig.hits.quantile.3[i] = mean(sample(body.non.sig.hits$piN_piS[body.non.sig.hits$quartile == 3], length(body.non.sig.hits$piN_piS[body.non.sig.hits$quartile == 3]), replace = TRUE))
  body.non.sig.hits.quantile.4[i] = mean(sample(body.non.sig.hits$piN_piS[body.non.sig.hits$quartile == 4], length(body.non.sig.hits$piN_piS[body.non.sig.hits$quartile == 4]), replace = TRUE))
  body.non.sig.hits.quantile.5[i] = mean(sample(body.non.sig.hits$piN_piS[body.non.sig.hits$quartile == 5], length(body.non.sig.hits$piN_piS[body.non.sig.hits$quartile == 5]), replace = TRUE))
  body.non.sig.hits.quantile.6[i] = mean(sample(body.non.sig.hits$piN_piS[body.non.sig.hits$quartile == 6], length(body.non.sig.hits$piN_piS[body.non.sig.hits$quartile == 6]), replace = TRUE))
  body.non.sig.hits.quantile.7[i] = mean(sample(body.non.sig.hits$piN_piS[body.non.sig.hits$quartile == 7], length(body.non.sig.hits$piN_piS[body.non.sig.hits$quartile == 7]), replace = TRUE))
  body.non.sig.hits.quantile.8[i] = mean(sample(body.non.sig.hits$piN_piS[body.non.sig.hits$quartile == 8], length(body.non.sig.hits$piN_piS[body.non.sig.hits$quartile == 8]), replace = TRUE))

  head.non.sig.hits.quantile.1[i] = mean(sample(head.non.sig.hits$piN_piS[head.non.sig.hits$quartile == 1], length(head.non.sig.hits$piN_piS[head.non.sig.hits$quartile == 1]), replace = TRUE))
  head.non.sig.hits.quantile.2[i] = mean(sample(head.non.sig.hits$piN_piS[head.non.sig.hits$quartile == 2], length(head.non.sig.hits$piN_piS[head.non.sig.hits$quartile == 2]), replace = TRUE))
  head.non.sig.hits.quantile.3[i] = mean(sample(head.non.sig.hits$piN_piS[head.non.sig.hits$quartile == 3], length(head.non.sig.hits$piN_piS[head.non.sig.hits$quartile == 3]), replace = TRUE))
  head.non.sig.hits.quantile.4[i] = mean(sample(head.non.sig.hits$piN_piS[head.non.sig.hits$quartile == 4], length(head.non.sig.hits$piN_piS[head.non.sig.hits$quartile == 4]), replace = TRUE))
  head.non.sig.hits.quantile.5[i] = mean(sample(head.non.sig.hits$piN_piS[head.non.sig.hits$quartile == 5], length(head.non.sig.hits$piN_piS[head.non.sig.hits$quartile == 5]), replace = TRUE))
  head.non.sig.hits.quantile.6[i] = mean(sample(head.non.sig.hits$piN_piS[head.non.sig.hits$quartile == 6], length(head.non.sig.hits$piN_piS[head.non.sig.hits$quartile == 6]), replace = TRUE))
  head.non.sig.hits.quantile.7[i] = mean(sample(head.non.sig.hits$piN_piS[head.non.sig.hits$quartile == 7], length(head.non.sig.hits$piN_piS[head.non.sig.hits$quartile == 7]), replace = TRUE))
  head.non.sig.hits.quantile.8[i] = mean(sample(head.non.sig.hits$piN_piS[head.non.sig.hits$quartile == 8], length(head.non.sig.hits$piN_piS[head.non.sig.hits$quartile == 8]), replace = TRUE))
print (i)
}

body.lower.CI = as.vector( c(  quantile(body.sig.hits.quantile.1, 0.05)[1],
                          quantile(body.sig.hits.quantile.2, 0.05)[1],
                          quantile(body.sig.hits.quantile.3, 0.05)[1],
                          quantile(body.sig.hits.quantile.4, 0.05)[1],
                          quantile(body.sig.hits.quantile.5, 0.05)[1],
                          quantile(body.sig.hits.quantile.6, 0.05)[1],
                          quantile(body.sig.hits.quantile.7, 0.05)[1],
                          quantile(body.sig.hits.quantile.8, 0.05)[1],
                          quantile(body.non.sig.hits.quantile.1, 0.05)[1],
                          quantile(body.non.sig.hits.quantile.2, 0.05)[1],
                          quantile(body.non.sig.hits.quantile.3, 0.05)[1],
                          quantile(body.non.sig.hits.quantile.4, 0.05)[1],
                          quantile(body.non.sig.hits.quantile.5, 0.05)[1],
                          quantile(body.non.sig.hits.quantile.6, 0.05)[1],
                          quantile(body.non.sig.hits.quantile.7, 0.05)[1],
                          quantile(body.non.sig.hits.quantile.8, 0.05)[1]))

body.upper.CI = as.vector( c( quantile(body.sig.hits.quantile.1, 0.95)[1],
                         quantile(body.sig.hits.quantile.2, 0.95)[1],
                         quantile(body.sig.hits.quantile.3, 0.95)[1],
                         quantile(body.sig.hits.quantile.4, 0.95)[1],
                         quantile(body.sig.hits.quantile.5, 0.95)[1],
                         quantile(body.sig.hits.quantile.6, 0.95)[1],
                         quantile(body.sig.hits.quantile.7, 0.95)[1],
                         quantile(body.sig.hits.quantile.8, 0.95)[1],
                         quantile(body.non.sig.hits.quantile.1, 0.95)[1],
                         quantile(body.non.sig.hits.quantile.2, 0.95)[1],
                         quantile(body.non.sig.hits.quantile.3, 0.95)[1],
                         quantile(body.non.sig.hits.quantile.4, 0.95)[1],
                         quantile(body.non.sig.hits.quantile.5, 0.95)[1],
                         quantile(body.non.sig.hits.quantile.6, 0.95)[1],
                         quantile(body.non.sig.hits.quantile.7, 0.95)[1],
                         quantile(body.non.sig.hits.quantile.8, 0.95)[1]))

head.lower.CI = as.vector( c(  quantile(head.sig.hits.quantile.1, 0.05)[1],
                          quantile(head.sig.hits.quantile.2, 0.05)[1],
                          quantile(head.sig.hits.quantile.3, 0.05)[1],
                          quantile(head.sig.hits.quantile.4, 0.05)[1],
                          quantile(head.sig.hits.quantile.5, 0.05)[1],
                          quantile(head.sig.hits.quantile.6, 0.05)[1],
                          quantile(head.sig.hits.quantile.7, 0.05)[1],
                          quantile(head.sig.hits.quantile.8, 0.05)[1],
                          quantile(head.non.sig.hits.quantile.1, 0.05)[1],
                          quantile(head.non.sig.hits.quantile.2, 0.05)[1],
                          quantile(head.non.sig.hits.quantile.3, 0.05)[1],
                          quantile(head.non.sig.hits.quantile.4, 0.05)[1],
                          quantile(head.non.sig.hits.quantile.5, 0.05)[1],
                          quantile(head.non.sig.hits.quantile.6, 0.05)[1],
                          quantile(head.non.sig.hits.quantile.7, 0.05)[1],
                          quantile(head.non.sig.hits.quantile.8, 0.05)[1]))

head.upper.CI = as.vector( c( quantile(head.sig.hits.quantile.1, 0.95)[1],
                         quantile(head.sig.hits.quantile.2, 0.95)[1],
                         quantile(head.sig.hits.quantile.3, 0.95)[1],
                         quantile(head.sig.hits.quantile.4, 0.95)[1],
                         quantile(head.sig.hits.quantile.5, 0.95)[1],
                         quantile(head.sig.hits.quantile.6, 0.95)[1],
                         quantile(head.sig.hits.quantile.7, 0.95)[1],
                         quantile(head.sig.hits.quantile.8, 0.95)[1],
                         quantile(head.non.sig.hits.quantile.1, 0.95)[1],
                         quantile(head.non.sig.hits.quantile.2, 0.95)[1],
                         quantile(head.non.sig.hits.quantile.3, 0.95)[1],
                         quantile(head.non.sig.hits.quantile.4, 0.95)[1],
                         quantile(head.non.sig.hits.quantile.5, 0.95)[1],
                         quantile(head.non.sig.hits.quantile.6, 0.95)[1],
                         quantile(head.non.sig.hits.quantile.7, 0.95)[1],
                         quantile(head.non.sig.hits.quantile.8, 0.95)[1]))


# Construct dataframes to hold all of our data for plotting
# Body
hit = rep(c("sig","non.sig"), each=8)
expression.quartile = rep(seq(1:8),2)
body.piN_piS.mean = c(body.sig.hits.mean$piN_piS.mean, body.non.sig.hits.mean$piN_piS.mean)
body.piN_piS.lowerCI = body.lower.CI
body.piN_piS.upperCI = body.upper.CI
body.piN_piS.df = as.data.frame(cbind(as.factor(hit),as.factor(expression.quartile), as.numeric(body.piN_piS.mean), as.numeric(body.piN_piS.lowerCI), as.numeric(body.piN_piS.upperCI)))
body.piN_piS.df$tissue = as.factor("body")
colnames(body.piN_piS.df) = c("hit", "expression.quartile", "piN_piS.mean", "piN_piS.lowerCI", "piN_piS.upperCI", "tissue")

# head
hit = rep(c("sig","non.sig"), each=8)
expression.quartile = rep(seq(1:8),2)
head.piN_piS.mean = c(head.sig.hits.mean$piN_piS.mean, head.non.sig.hits.mean$piN_piS.mean)
head.piN_piS.lowerCI = head.lower.CI
head.piN_piS.upperCI = head.upper.CI
head.piN_piS.df = as.data.frame(cbind(as.factor(hit),as.factor(expression.quartile), as.numeric(head.piN_piS.mean), as.numeric(head.piN_piS.lowerCI), as.numeric(head.piN_piS.upperCI)))
head.piN_piS.df$tissue = as.factor("head")
colnames(head.piN_piS.df) = c("hit", "expression.quartile", "piN_piS.mean", "piN_piS.lowerCI", "piN_piS.upperCI", "tissue")

## Combined plots
piN_piS.df = rbind(body.piN_piS.df, head.piN_piS.df)

## Body piN/piS plot
body.piN_piS.expression.plot = ggplot(body.piN_piS.df, aes(y = piN_piS.mean, x = as.factor(expression.quartile), colour = as.factor(hit))) +
                                      geom_point(aes(x = as.factor(expression.quartile), y = piN_piS.mean, colour = as.factor(hit)),size = 10,
                                      position = position_dodge(width = 0.5)) + scale_y_continuous(limits = c(0, 3)) +
                                      geom_errorbar(aes(ymin = piN_piS.lowerCI, ymax = piN_piS.upperCI, x = as.factor(expression.quartile), colour=as.factor(hit)),
                                      width = 0, position = position_dodge(width = 0.5)) + geom_hline(yintercept = 1) +
                                      theme_bw() + scale_colour_manual(values = c("#7294D4", "#5B1A18")) +
                                      theme(panel.grid.major=element_blank(), panel.grid.minor=element_blank(),
                                            panel.border = element_rect(colour = "black", fill=NA, size=1),
                                            axis.text = element_text(face="bold", color="black",size=40, family = "Helvetica"),
                                            axis.title=element_blank(), legend.position = "none")
body.piN_piS.expression.plot

## Head piN/piS plot
head.piN_piS.expression.plot = ggplot(head.piN_piS.df, aes(y = piN_piS.mean, x = as.factor(expression.quartile), colour = as.factor(hit))) +
                                      geom_point(aes(x = as.factor(expression.quartile), y = piN_piS.mean, colour = as.factor(hit)),size = 10,
                                      position = position_dodge(width = 0.5)) + #scale_y_continuous(limits = c(0, 10)) +
                                      geom_errorbar(aes(ymin = piN_piS.lowerCI, ymax = piN_piS.upperCI, x = as.factor(expression.quartile), colour=as.factor(hit)),
                                      width = 0, position = position_dodge(width = 0.5)) + geom_hline(yintercept = 1) +
                                      theme_bw() + scale_colour_manual(values = c("#7294D4", "#5B1A18")) +
                                      theme(panel.grid.major=element_blank(), panel.grid.minor=element_blank(),
                                            panel.border = element_rect(colour = "black", fill=NA, size=1),
                                            axis.text = element_text(face="bold", color="black",size=40, family = "Helvetica"),
                                            axis.title=element_blank(), legend.position = "none")
head.piN_piS.expression.plot

## Body/head piN/piS plot
piN_piS.expression.plot = ggplot(piN_piS.df, aes(y = piN_piS.mean, x = as.factor(expression.quartile), colour = as.factor(hit))) +
                                      geom_point(aes(x = as.factor(expression.quartile), y = piN_piS.mean, colour = as.factor(hit)),size = 10,
                                      position = position_dodge(width = 0.5)) + #scale_y_continuous(limits = c(-0.1, 0.1)) +
                                      geom_errorbar(aes(ymin = piN_piS.lowerCI, ymax = piN_piS.upperCI, x = as.factor(expression.quartile), colour=as.factor(hit)),
                                      width = 0.25, position = position_dodge(width = 0.5)) + geom_hline(yintercept = 1) +
                                      scale_colour_manual(values = c("#7294D4", "#5B1A18")) +
                                      theme_bw()  +
                                      theme(panel.grid.major=element_blank(), panel.grid.minor=element_blank(),
                                            panel.border = element_rect(colour = "black", fill=NA, size=1),
                                            axis.text = element_text(face="bold", color="black",size=20, family = "Helvetica"),
                                            axis.title=element_blank(), legend.position = "none") +
                                      facet_grid(tissue ~ .,  scales = "free")
piN_piS.expression.plot









###### This deprecated method was done by using synonymous variants as synonymous sites  #####

## Calculate piN and piS per gene
# Merge the nucleotide diversity and VEP output files
pi.vep.merge = merge(pi.output, vep.output, by.x = "site", by.y = "Location")
# Clean out unnecessary columns
pi.vep.merge = pi.vep.merge[, c(1,4,7,10)]
pi.vep.merge.syn.sub = pi.vep.merge[pi.vep.merge$Consequence == "synonymous_variant",]
pi.vep.merge.non.syn.sub = pi.vep.merge[pi.vep.merge$Consequence != "synonymous_variant",]

pi.syn.per.gene = summaryBy(PI ~ Gene, FUN = c(mean), data = pi.vep.merge.syn.sub)
pi.non.syn.per.gene = summaryBy(PI ~ Gene, FUN = c(mean), data = pi.vep.merge.non.syn.sub)
# Rename columns and then merge datafiles
colnames(pi.syn.per.gene)[2] = "piS"
colnames(pi.non.syn.per.gene)[2] = "piNS"
piNpiS.per.gene = merge(pi.syn.per.gene,pi.non.syn.per.gene, by = "Gene")

## Assign significant genes from JunctionSeq output
# Assign significant hits
junctionseq.results.body$sig.hit = NA
junctionseq.results.body$sig.hit[junctionseq.results.body$geneWisePadj <= 0.01] = 1
junctionseq.results.body$sig.hit[!(junctionseq.results.body$geneWisePadj <= 0.01)] = 0

junctionseq.results.head$sig.hit = NA
junctionseq.results.head$sig.hit[junctionseq.results.head$geneWisePadj <= 0.01] = 1
junctionseq.results.head$sig.hit[!(junctionseq.results.head$geneWisePadj <= 0.01)] = 0

# Collapse duplicates in Junctionseq files
junctionseq.results.body.unique = junctionseq.results.body[!duplicated(junctionseq.results.body[c(1,4:5)]), ]
junctionseq.results.head.unique = junctionseq.results.head[!duplicated(junctionseq.results.head[c(1,4:5)]), ]

# Merge piN/piS data with junctionseq data
body.pin.pis = merge(junctionseq.results.body.unique,piNpiS.per.gene, by.x = "geneID", by.y = "Gene", sort = FALSE)
head.pin.pis = merge(junctionseq.results.head.unique,piNpiS.per.gene, by.x = "geneID", by.y = "Gene", sort = FALSE)



### Plotting piN and piS





#
